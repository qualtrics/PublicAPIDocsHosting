/**
 * @since 0.1.0
 */
import { Alternative1 } from "fp-ts/lib/Alternative";
import { Task } from "fp-ts/lib/Task";
import { Monad1 } from "fp-ts/lib/Monad";
import { Option } from "fp-ts/lib/Option";
import { TaskEither } from "fp-ts/lib/TaskEither";
import { Lazy } from "fp-ts/lib/function";
import { Filterable1 } from "fp-ts/lib/Filterable";
declare module "fp-ts/lib/HKT" {
  interface URItoKind<A> {
    TaskOption: TaskOption<A>;
  }
}
/**
 * @since 0.1.0
 */
export declare const URI = "TaskOption";
/**
 * @since 0.1.0
 */
export declare type URI = typeof URI;
/**
 * @since 0.1.0
 */
export interface TaskOption<A> extends Task<Option<A>> {}
/**
 * @since 0.1.0
 */
export declare const fromTask: <A>(as: Task<A>) => TaskOption<A>;
/**
 * @since 0.1.0
 */
export declare const fromOption: <A>(ma: Option<A>) => TaskOption<A>;
/**
 * @since 0.1.0
 */
export declare const none: TaskOption<never>;
/**
 * @since 0.1.0
 */
export declare const some: <A>(a: A) => TaskOption<A>;
/**
 * @since 0.1.0
 */
export declare function fold<A, B>(
  onNone: () => Task<B>,
  onSome: (a: A) => Task<B>
): (as: TaskOption<A>) => Task<B>;
/**
 * @since 0.1.0
 */
export declare function getOrElse<A>(
  onNone: () => Task<A>
): (as: TaskOption<A>) => Task<A>;
/**
 * @since 0.1.4
 */
export declare function fromNullable<A>(a: A): TaskOption<NonNullable<A>>;
/**
 * @since 0.1.4
 */
export declare function fromTaskEither<A>(
  ma: TaskEither<any, A>
): TaskOption<A>;
/**
 * @since 0.1.4
 */
export declare function toUndefined<A>(ma: TaskOption<A>): Task<A | undefined>;
/**
 * @since 0.1.4
 */
export declare function toNullable<A>(ma: TaskOption<A>): Task<A | null>;
/**
 * @since 0.1.4
 */
export declare function chainTask<A, B>(
  f: (a: A) => Task<B>
): (ma: TaskOption<A>) => TaskOption<B>;
/**
 * @since 0.1.4
 */
export declare function chainOption<A, B>(
  f: (a: A) => Option<B>
): (ma: TaskOption<A>) => TaskOption<B>;
/**
 * @since 0.1.5
 */
export declare function mapNullable<A, B>(
  f: (a: A) => B | null | undefined
): (ma: TaskOption<A>) => TaskOption<B>;
/**
 * @since 0.1.5
 */
export declare function tryCatch<A>(f: Lazy<Promise<A>>): TaskOption<A>;
/**
 * @since 0.1.10
 */
export declare function fromOptionK<A extends Array<unknown>, B>(
  f: (...a: A) => Option<B>
): (...a: A) => TaskOption<B>;
/**
 * @since 0.1.10
 */
export declare function chainOptionK<A, B>(
  f: (a: A) => Option<B>
): (ma: TaskOption<A>) => TaskOption<B>;
/**
 * @since 0.1.0
 */
export declare const taskOption: Monad1<URI> &
  Alternative1<URI> &
  Filterable1<URI>;
declare const alt: <A>(
    that: () => TaskOption<A>
  ) => (fa: TaskOption<A>) => TaskOption<A>,
  ap: <A>(
    fa: TaskOption<A>
  ) => <B>(fab: TaskOption<(a: A) => B>) => TaskOption<B>,
  apFirst: <B>(fb: TaskOption<B>) => <A>(fa: TaskOption<A>) => TaskOption<A>,
  apSecond: <B>(fb: TaskOption<B>) => <A>(fa: TaskOption<A>) => TaskOption<B>,
  chain: <A, B>(
    f: (a: A) => TaskOption<B>
  ) => (ma: TaskOption<A>) => TaskOption<B>,
  chainFirst: <A, B>(
    f: (a: A) => TaskOption<B>
  ) => (ma: TaskOption<A>) => TaskOption<A>,
  flatten: <A>(mma: TaskOption<TaskOption<A>>) => TaskOption<A>,
  map: <A, B>(f: (a: A) => B) => (fa: TaskOption<A>) => TaskOption<B>,
  partition: {
    <A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>
    ): (
      fa: TaskOption<A>
    ) => import("fp-ts/lib/Compactable").Separated<
      TaskOption<A>,
      TaskOption<B>
    >;
    <A_1>(predicate: import("fp-ts/lib/function").Predicate<A_1>): (
      fa: TaskOption<A_1>
    ) => import("fp-ts/lib/Compactable").Separated<
      TaskOption<A_1>,
      TaskOption<A_1>
    >;
  },
  partitionMap: <A, B, C>(
    f: (a: A) => import("fp-ts/lib/Either").Either<B, C>
  ) => (
    fa: TaskOption<A>
  ) => import("fp-ts/lib/Compactable").Separated<TaskOption<B>, TaskOption<C>>,
  filter: {
    <A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>
    ): (fa: TaskOption<A>) => TaskOption<B>;
    <A_1>(predicate: import("fp-ts/lib/function").Predicate<A_1>): (
      fa: TaskOption<A_1>
    ) => TaskOption<A_1>;
  },
  filterMap: <A, B>(
    f: (a: A) => Option<B>
  ) => (fa: TaskOption<A>) => TaskOption<B>,
  compact: <A>(fa: TaskOption<Option<A>>) => TaskOption<A>,
  separate: <A, B>(
    fa: TaskOption<import("fp-ts/lib/Either").Either<A, B>>
  ) => import("fp-ts/lib/Compactable").Separated<TaskOption<A>, TaskOption<B>>;
export {
  /**
   * @since 0.1.0
   */
  alt,
  /**
   * @since 0.1.0
   */
  ap,
  /**
   * @since 0.1.0
   */
  apFirst,
  /**
   * @since 0.1.0
   */
  apSecond,
  /**
   * @since 0.1.0
   */
  chain,
  /**
   * @since 0.1.0
   */
  chainFirst,
  /**
   * @since 0.1.0
   */
  flatten,
  /**
   * @since 0.1.0
   */
  map,
  /**
   * @since 0.1.5
   */
  partition,
  /**
   * @since 0.1.5
   */
  partitionMap,
  /**
   * @since 0.1.5
   */
  filter,
  /**
   * @since 0.1.5
   */
  filterMap,
  /**
   * @since 0.1.5
   */
  compact,
  /**
   * @since 0.1.5
   */
  separate
};
