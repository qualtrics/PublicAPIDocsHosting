"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @since 0.1.0
 */
var These_1 = require("fp-ts/lib/These");
var Array_1 = require("fp-ts/lib/Array");
var Option_1 = require("fp-ts/lib/Option");
var function_1 = require("fp-ts/lib/function");
var _1 = require("./");
/**
 * `Align` instance for `Array`.
 *
 * @since 0.1.0
 */
exports.alignArray = {
    URI: Array_1.URI,
    map: Array_1.array.map,
    /**
     * Unit value in regards to `align`
     */
    nil: function () { return []; },
    /**
     * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array.
     * Uses the `These` data type to handle arrays of different lengths.
     *
     * @example
     * import { These } from 'fp-ts/lib/These'
     * import { identity } from 'fp-ts/lib/function'
     * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'
     *
     * const f = (x: These<number, string>) => x.fold(a => a.toString(), identity, (a, b) => a + b)
     *
     * assert.deepStrictEqual(alignArray.alignWith([1, 2], ['a', 'b'], f), ['1a', '2b'])
     * assert.deepStrictEqual(alignArray.alignWith([1, 2], ['a'], f), ['1a', '2'])
     * assert.deepStrictEqual(alignArray.alignWith([1], ['a' 'b'], f), ['1a', 'b'])
     *
     * @since 0.1.0
     */
    alignWith: function (fa, fb, f) {
        var fc = [];
        var aLen = fa.length;
        var bLen = fb.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
            fc[i] = f(These_1.both(fa[i], fb[i]));
        }
        if (aLen > bLen) {
            for (var i = bLen; i < aLen; i++) {
                fc[i] = f(These_1.left(fa[i]));
            }
        }
        else {
            for (var i = aLen; i < bLen; i++) {
                fc[i] = f(These_1.right(fb[i]));
            }
        }
        return fc;
    },
    /**
     * Takes two arrays and returns an array of corresponding pairs combined using the `These` data type.
     *
     * @example
     * import { These } from 'fp-ts/lib/These'
     * import { identity } from 'fp-ts/lib/function'
     * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'
     *
     * assert.deepStrictEqual(alignArray.align([1, 2], ['a', 'b']), [both(1, 'a'), both(2, 'b')])
     * assert.deepStrictEqual(alignArray.align([1, 2], ['a']), [both(1, 'a'), left(2)])
     * assert.deepStrictEqual(alignArray.align([1], ['a' 'b']), [both(1, 'a'), right('b')])
     *
     * @since 0.1.0
     */
    align: function (fa, fb) {
        return exports.alignArray.alignWith(fa, fb, function_1.identity);
    }
};
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the
 * left input array is short, it will be padded using `none`.
 *
 * It is similar to `zipWith`, but it doesn't discard elements when the left input array is shorter than the right.
 *
 * @example
 * import * as O from 'fp-ts/lib/Option'
 * import { lpadZipWith } from 'fp-ts-contrib/lib/Align/Array'
 * import { pipe } from 'fp-ts/lib/pipeable'
 *
 * const f = (ma: O.Option<number>, b: string) =>
 *   pipe(
 *     ma,
 *     O.fold(() => '*', a => a.toString())
 *   ) + b
 * assert.deepStrictEqual(lpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c', '*d'])
 * assert.deepStrictEqual(lpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c'])
 *
 * @since 0.1.0
 */
function lpadZipWith(xs, ys, f) {
    return Array_1.array.compact(_1.padZipWith(exports.alignArray)(xs, ys, function (ma, mb) { return Option_1.option.map(mb, function (b) { return f(ma, b); }); }));
}
exports.lpadZipWith = lpadZipWith;
/**
 * Takes two arrays and returns an array of corresponding pairs. If the left input array is short, it will be
 * padded using `none`.
 *
 * It is similar to `zip`, but it doesn't discard elements when the left input array is shorter than the right.
 *
 * @example
 * import { some, none } from 'fp-ts/lib/Option'
 * import { lpadZip } from 'fp-ts-contrib/lib/Align/Array'
 *
 * assert.deepStrictEqual(lpadZip([1, 2], ['a', 'b', 'c']), [[some(1), 'a'], [some(2), 'b'], [none, 'c']])
 * assert.deepStrictEqual(lpadZip([1, 2, 3], ['a', 'b']), [[some(1), 'a'], [some(2), 'b']])
 *
 * @since 0.1.0
 */
function lpadZip(xs, ys) {
    return lpadZipWith(xs, ys, function (a, b) { return function_1.tuple(a, b); });
}
exports.lpadZip = lpadZip;
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the
 * right input array is short, it will be padded using `none`.
 *
 * It is similar to `zipWith`, but it doesn't discard elements when the right input array is shorter than the left.
 *
 * @example
 * import { Option, getOrElse } from 'fp-ts/lib/Option'
 * import { rpadZipWith } from 'fp-ts-contrib/lib/Align/Array'
 *
 * const f = (a: number, mb: Option<string>) => a.toString() + getOrElse(() => '*')(mb)
 * assert.deepStrictEqual(rpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c', '4*'])
 * assert.deepStrictEqual(rpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c'])
 *
 * @since 0.1.0
 */
function rpadZipWith(xs, ys, f) {
    return lpadZipWith(ys, xs, function (a, b) { return f(b, a); });
}
exports.rpadZipWith = rpadZipWith;
/**
 * Takes two arrays and returns an array of corresponding pairs. If the right input array is short, it will be
 * padded using `none`.
 *
 * It is similar to `zip`, but it doesn't discard elements when the right input array is shorter than the left.
 *
 * @example
 * import { some, none } from 'fp-ts/lib/Option'
 * import { rpadZip } from 'fp-ts-contrib/lib/Align/Array'
 *
 * assert.deepStrictEqual(rpadZip([1, 2, 3], ['a', 'b']), [[1, some('a')], [2, some('b')], [3, none]])
 * assert.deepStrictEqual(rpadZip([1, 2], ['a', 'b', 'c']), [[1, some('a')], [2, some('b')]])
 *
 * @since 0.1.0
 */
function rpadZip(xs, ys) {
    return rpadZipWith(xs, ys, function (a, b) { return function_1.tuple(a, b); });
}
exports.rpadZip = rpadZip;
