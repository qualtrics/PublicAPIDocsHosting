"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @since 0.1.0
 */
var Option_1 = require("fp-ts/lib/Option");
var These_1 = require("fp-ts/lib/These");
var function_1 = require("fp-ts/lib/function");
/**
 * `Align` instance for `Option`.
 *
 * @since 0.1.0
 */
exports.alignOption = {
    URI: Option_1.URI,
    map: Option_1.option.map,
    /**
     * Unit value in regards to `align`
     *
     * @since 0.1.0
     */
    nil: function () { return Option_1.none; },
    /**
     * Apply a function to the values of two Option's, returning an Option with the result. Uses the `These` data type
     * to handle the possibility of non existing values.
     *
     * @example
     * import { some, none } from 'fp-ts/lib/Option'
     * import { These } from 'fp-ts/lib/These'
     * import { identity } from 'fp-ts/lib/function'
     * import { alignOption } from 'fp-ts-contrib/lib/Align/Option'
     *
     * const f = (x: These<number, string>) => x.fold(a => a.toString(), identity, (a, b) => a + b)
     *
     * assert.deepStrictEqual(alignOption.alignWith(some(1), some('a'), f), some('1a'))
     * assert.deepStrictEqual(alignOption.alignWith(some(1), none, f), some('1'))
     * assert.deepStrictEqual(alignOption.alignWith(none, some('a'), f), some('a'))
     * assert.deepStrictEqual(alignOption.alignWith(none, none, f), none)
     *
     * @since 0.1.0
     */
    alignWith: function (fa, fb, f) {
        if (Option_1.isSome(fa) && Option_1.isSome(fb)) {
            return Option_1.some(f(These_1.both(fa.value, fb.value)));
        }
        else if (Option_1.isNone(fa) && Option_1.isSome(fb)) {
            return Option_1.some(f(These_1.right(fb.value)));
        }
        else if (Option_1.isSome(fa) && Option_1.isNone(fb)) {
            return Option_1.some(f(These_1.left(fa.value)));
        }
        else {
            return Option_1.none;
        }
    },
    /**
     * Takes two Option's and returns an Option with a value corresponding to the inputs combined using the `These` data type.
     *
     * @example
     * import { some, none } from 'fp-ts/lib/Option'
     * import { both, left, right } from 'fp-ts/lib/These'
     * import { alignOption } from 'fp-ts-contrib/lib/Align/Option'
     *
     * assert.deepStrictEqual(alignOption.align(some(1), some('a')), some(both(1, 'a')))
     * assert.deepStrictEqual(alignOption.align(some(1, none), some(left(1)))
     * assert.deepStrictEqual(alignOption.align(none, some('a')), some(right('a')))
     * assert.deepStrictEqual(alignOption.align(none, none), none)
     *
     * @since 0.1.0
     */
    align: function (fa, fb) { return exports.alignOption.alignWith(fa, fb, function_1.identity); }
};
