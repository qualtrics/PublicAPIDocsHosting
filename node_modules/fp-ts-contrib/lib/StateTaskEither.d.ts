/**
 * @since 0.1.0
 */
import { Either } from "fp-ts/lib/Either";
import { IO } from "fp-ts/lib/IO";
import { IOEither } from "fp-ts/lib/IOEither";
import { Monad3 } from "fp-ts/lib/Monad";
import { MonadThrow3 } from "fp-ts/lib/MonadThrow";
import { State } from "fp-ts/lib/State";
import { Task } from "fp-ts/lib/Task";
import * as TE from "fp-ts/lib/TaskEither";
import TaskEither = TE.TaskEither;
declare module "fp-ts/lib/HKT" {
  interface URItoKind3<R, E, A> {
    StateTaskEither: StateTaskEither<R, E, A>;
  }
}
/**
 * @since 0.1.0
 */
export declare const URI = "StateTaskEither";
/**
 * @since 0.1.0
 */
export declare type URI = typeof URI;
/**
 * @since 0.1.0
 */
export interface StateTaskEither<S, E, A> {
  (s: S): TaskEither<E, [A, S]>;
}
/**
 * @since 0.1.0
 */
export declare function run<S, E, A>(
  ma: StateTaskEither<S, E, A>,
  s: S
): Promise<Either<E, [A, S]>>;
/**
 * @since 0.1.0
 */
export declare const evalState: <S, E, A>(
  ma: StateTaskEither<S, E, A>,
  s: S
) => TaskEither<E, A>;
/**
 * @since 0.1.0
 */
export declare const execState: <S, E, A>(
  ma: StateTaskEither<S, E, A>,
  s: S
) => TaskEither<E, S>;
/**
 * @since 0.1.0
 */
export declare function left<S, E>(e: E): StateTaskEither<S, E, never>;
/**
 * @since 0.1.0
 */
export declare const right: <S, A>(a: A) => StateTaskEither<S, never, A>;
/**
 * @since 0.1.0
 */
export declare function rightTask<S, A>(
  ma: Task<A>
): StateTaskEither<S, never, A>;
/**
 * @since 0.1.0
 */
export declare function leftTask<S, E>(
  me: Task<E>
): StateTaskEither<S, E, never>;
/**
 * @since 0.1.0
 */
export declare const fromTaskEither: <S, E, A>(
  ma: TaskEither<E, A>
) => StateTaskEither<S, E, A>;
/**
 * @since 0.1.0
 */
export declare function fromIOEither<S, E, A>(
  ma: IOEither<E, A>
): StateTaskEither<S, E, A>;
/**
 * @since 0.1.0
 */
export declare function rightIO<S, A>(ma: IO<A>): StateTaskEither<S, never, A>;
/**
 * @since 0.1.0
 */
export declare function leftIO<S, E>(me: IO<E>): StateTaskEither<S, E, never>;
/**
 * @since 0.1.0
 */
export declare const rightState: <S, A>(
  ma: State<S, A>
) => StateTaskEither<S, never, A>;
/**
 * @since 0.1.0
 */
export declare function leftState<S, E>(
  me: State<S, E>
): StateTaskEither<S, E, never>;
/**
 * @since 0.1.0
 */
export declare const get: <S>() => StateTaskEither<S, never, S>;
/**
 * @since 0.1.0
 */
export declare const put: <S>(s: S) => StateTaskEither<S, never, void>;
/**
 * @since 0.1.0
 */
export declare const modify: <S>(
  f: (s: S) => S
) => StateTaskEither<S, never, void>;
/**
 * @since 0.1.0
 */
export declare const gets: <S, A>(
  f: (s: S) => A
) => StateTaskEither<S, never, A>;
/**
 * @since 0.1.10
 */
export declare function fromEitherK<E, A extends Array<unknown>, B>(
  f: (...a: A) => Either<E, B>
): <S>(...a: A) => StateTaskEither<S, E, B>;
/**
 * @since 0.1.10
 */
export declare function chainEitherK<E, A, B>(
  f: (a: A) => Either<E, B>
): <S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B>;
/**
 * @since 0.1.10
 */
export declare function fromIOEitherK<E, A extends Array<unknown>, B>(
  f: (...a: A) => IOEither<E, B>
): <S>(...a: A) => StateTaskEither<S, E, B>;
/**
 * @since 0.1.10
 */
export declare function chainIOEitherK<E, A, B>(
  f: (a: A) => IOEither<E, B>
): <S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B>;
/**
 * @since 0.1.10
 */
export declare function fromTaskEitherK<E, A extends Array<unknown>, B>(
  f: (...a: A) => TaskEither<E, B>
): <S>(...a: A) => StateTaskEither<S, E, B>;
/**
 * @since 0.1.10
 */
export declare function chainTaskEitherK<E, A, B>(
  f: (a: A) => TaskEither<E, B>
): <S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B>;
/**
 * @since 0.1.0
 */
export declare const stateTaskEither: Monad3<URI> & MonadThrow3<URI>;
/**
 * Like `stateTaskEither` but `ap` is sequential
 * @since 0.1.0
 */
export declare const stateTaskEitherSeq: typeof stateTaskEither;
declare const ap: <R, E, A>(
    fa: StateTaskEither<R, E, A>
  ) => <B>(fab: StateTaskEither<R, E, (a: A) => B>) => StateTaskEither<R, E, B>,
  apFirst: <R, E, B>(
    fb: StateTaskEither<R, E, B>
  ) => <A>(fa: StateTaskEither<R, E, A>) => StateTaskEither<R, E, A>,
  apSecond: <R, E, B>(
    fb: StateTaskEither<R, E, B>
  ) => <A>(fa: StateTaskEither<R, E, A>) => StateTaskEither<R, E, B>,
  chain: <R, E, A, B>(
    f: (a: A) => StateTaskEither<R, E, B>
  ) => (ma: StateTaskEither<R, E, A>) => StateTaskEither<R, E, B>,
  chainFirst: <R, E, A, B>(
    f: (a: A) => StateTaskEither<R, E, B>
  ) => (ma: StateTaskEither<R, E, A>) => StateTaskEither<R, E, A>,
  flatten: <R, E, A>(
    mma: StateTaskEither<R, E, StateTaskEither<R, E, A>>
  ) => StateTaskEither<R, E, A>,
  map: <A, B>(
    f: (a: A) => B
  ) => <R, E>(fa: StateTaskEither<R, E, A>) => StateTaskEither<R, E, B>,
  filterOrElse: {
    <E, A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>,
      onFalse: (a: A) => E
    ): <R>(ma: StateTaskEither<R, E, A>) => StateTaskEither<R, E, B>;
    <E_1, A_1>(
      predicate: import("fp-ts/lib/function").Predicate<A_1>,
      onFalse: (a: A_1) => E_1
    ): <R_1>(
      ma: StateTaskEither<R_1, E_1, A_1>
    ) => StateTaskEither<R_1, E_1, A_1>;
  },
  fromEither: <R, E, A>(ma: Either<E, A>) => StateTaskEither<R, E, A>,
  fromOption: <E>(
    onNone: () => E
  ) => <R, A>(
    ma: import("fp-ts/lib/Option").Option<A>
  ) => StateTaskEither<R, E, A>,
  fromPredicate: {
    <E, A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>,
      onFalse: (a: A) => E
    ): <U>(a: A) => StateTaskEither<U, E, B>;
    <E_1, A_1>(
      predicate: import("fp-ts/lib/function").Predicate<A_1>,
      onFalse: (a: A_1) => E_1
    ): <R>(a: A_1) => StateTaskEither<R, E_1, A_1>;
  };
export {
  /**
   * @since 0.1.0
   */
  ap,
  /**
   * @since 0.1.0
   */
  apFirst,
  /**
   * @since 0.1.0
   */
  apSecond,
  /**
   * @since 0.1.0
   */
  chain,
  /**
   * @since 0.1.0
   */
  chainFirst,
  /**
   * @since 0.1.0
   */
  flatten,
  /**
   * @since 0.1.0
   */
  map,
  /**
   * @since 0.1.0
   */
  filterOrElse,
  /**
   * @since 0.1.0
   */
  fromEither,
  /**
   * @since 0.1.0
   */
  fromOption,
  /**
   * @since 0.1.0
   */
  fromPredicate
};
