"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var A = require("fp-ts/lib/Array");
var function_1 = require("fp-ts/lib/function");
var Option_1 = require("fp-ts/lib/Option");
var pipeable_1 = require("fp-ts/lib/pipeable");
/**
 * @since 0.1.6
 */
exports.URI = 'Zipper';
/**
 * Creates a new zipper.
 * @since 0.1.6
 */
function make(lefts, focus, rights) {
    return { lefts: lefts, focus: focus, rights: rights };
}
exports.make = make;
/**
 * @since 0.1.6
 */
function length(fa) {
    return fa.lefts.length + 1 + fa.rights.length;
}
exports.length = length;
/**
 * Updates the focus of the zipper.
 * @since 0.1.6
 */
function update(a) {
    return function (fa) { return make(fa.lefts, a, fa.rights); };
}
exports.update = update;
/**
 * Applies `f` to the focus and update with the result.
 * @since 0.1.6
 */
function modify(f) {
    return function (fa) { return pipeable_1.pipe(fa, update(f(fa.focus))); };
}
exports.modify = modify;
/**
 * @since 0.1.6
 */
function toArray(fa) {
    return A.snoc(fa.lefts, fa.focus).concat(fa.rights);
}
exports.toArray = toArray;
/**
 * @since 0.1.6
 */
function isOutOfBound(index, fa) {
    return index < 0 || index >= length(fa);
}
exports.isOutOfBound = isOutOfBound;
/**
 * Moves focus in the zipper, or `None` if there is no such element.
 * @since 0.1.6
 */
function move(f, fa) {
    var newIndex = f(fa.lefts.length);
    if (isOutOfBound(newIndex, fa)) {
        return Option_1.none;
    }
    else {
        return fromArray(toArray(fa), newIndex);
    }
}
exports.move = move;
/**
 * Moves focus of the zipper up.
 * @since 0.1.6
 */
function up(fa) {
    return move(function_1.decrement, fa);
}
exports.up = up;
/**
 * Moves focus of the zipper down.
 * @since 0.1.6
 */
function down(fa) {
    return move(function_1.increment, fa);
}
exports.down = down;
/**
 * Moves focus to the start of the zipper.
 * @since 0.1.6
 */
function start(fa) {
    if (A.isEmpty(fa.lefts)) {
        return fa;
    }
    else {
        return make(A.empty, fa.lefts[0], A.snoc(pipeable_1.pipe(fa.lefts, A.dropLeft(1)), fa.focus).concat(fa.rights));
    }
}
exports.start = start;
/**
 * Moves focus to the end of the zipper.
 * @since 0.1.6
 */
function end(fa) {
    var len = fa.rights.length;
    if (len === 0) {
        return fa;
    }
    else {
        return make(A.snoc(fa.lefts, fa.focus).concat(pipeable_1.pipe(fa.rights, A.takeLeft(len - 1))), fa.rights[len - 1], A.empty);
    }
}
exports.end = end;
/**
 * Inserts an element to the left of the focus and focuses on the new element.
 * @since 0.1.6
 */
function insertLeft(a) {
    return function (fa) { return make(fa.lefts, a, A.cons(fa.focus, fa.rights)); };
}
exports.insertLeft = insertLeft;
/**
 * Inserts an element to the right of the focus and focuses on the new element.
 * @since 0.1.6
 */
function insertRight(a) {
    return function (fa) { return make(A.snoc(fa.lefts, fa.focus), a, fa.rights); };
}
exports.insertRight = insertRight;
/**
 * Deletes the element at focus and moves the focus to the left. If there is no element on the left,
 * the focus is moved to the right.
 * @since 0.1.6
 */
function deleteLeft(fa) {
    var len = fa.lefts.length;
    return fromArray(fa.lefts.concat(fa.rights), len > 0 ? len - 1 : 0);
}
exports.deleteLeft = deleteLeft;
/**
 * Deletes the element at focus and moves the focus to the right. If there is no element on the right,
 * the focus is moved to the left.
 * @since 0.1.6
 */
function deleteRight(fa) {
    var lenl = fa.lefts.length;
    var lenr = fa.rights.length;
    return fromArray(fa.lefts.concat(fa.rights), lenr > 0 ? lenl : lenl - 1);
}
exports.deleteRight = deleteRight;
/**
 * @since 0.1.6
 */
function getShow(S) {
    var SA = A.getShow(S);
    return {
        show: function (fa) { return "Zipper(" + SA.show(fa.lefts) + ", " + S.show(fa.focus) + ", " + SA.show(fa.rights) + ")"; }
    };
}
exports.getShow = getShow;
/**
 * @since 0.1.6
 */
function fromArray(as, focusIndex) {
    if (focusIndex === void 0) { focusIndex = 0; }
    if (A.isEmpty(as) || A.isOutOfBound(focusIndex, as)) {
        return Option_1.none;
    }
    else {
        return Option_1.some(make(pipeable_1.pipe(as, A.takeLeft(focusIndex)), as[focusIndex], pipeable_1.pipe(as, A.dropLeft(focusIndex + 1))));
    }
}
exports.fromArray = fromArray;
/**
 * @since 0.1.6
 */
function fromNonEmptyArray(nea) {
    return make(A.empty, nea[0], nea.slice(1));
}
exports.fromNonEmptyArray = fromNonEmptyArray;
/**
 * @since 0.1.6
 */
function of(focus) {
    return make(A.empty, focus, A.empty);
}
exports.of = of;
function traverse(F) {
    var traverseF = A.array.traverse(F);
    return function (ta, f) {
        return F.ap(F.ap(F.map(traverseF(ta.lefts, f), function (lefts) { return function (focus) { return function (rights) { return make(lefts, focus, rights); }; }; }), f(ta.focus)), traverseF(ta.rights, f));
    };
}
function sequence(F) {
    var sequenceF = A.array.sequence(F);
    return function (ta) {
        return F.ap(F.ap(F.map(sequenceF(ta.lefts), function (lefts) { return function (focus) { return function (rights) { return make(lefts, focus, rights); }; }; }), ta.focus), sequenceF(ta.rights));
    };
}
/**
 * @since 0.1.6
 */
function getSemigroup(S) {
    return {
        concat: function (x, y) { return make(x.lefts.concat(y.lefts), S.concat(x.focus, y.focus), x.rights.concat(y.rights)); }
    };
}
exports.getSemigroup = getSemigroup;
/**
 * @since 0.1.6
 */
function getMonoid(M) {
    return __assign(__assign({}, getSemigroup(M)), { empty: make(A.empty, M.empty, A.empty) });
}
exports.getMonoid = getMonoid;
/**
 * @since 0.1.6
 */
exports.zipper = {
    URI: exports.URI,
    map: function (z, f) { return make(z.lefts.map(f), f(z.focus), z.rights.map(f)); },
    of: of,
    ap: function (fab, fa) { return make(A.array.ap(fab.lefts, fa.lefts), fab.focus(fa.focus), A.array.ap(fab.rights, fa.rights)); },
    extend: function (fa, f) {
        var lefts = fa.lefts.map(function (a, i) {
            return f(make(pipeable_1.pipe(fa.lefts, A.takeLeft(i)), a, A.snoc(pipeable_1.pipe(fa.lefts, A.dropLeft(i + 1)), fa.focus).concat(fa.rights)));
        });
        var rights = fa.rights.map(function (a, i) {
            return f(make(A.snoc(fa.lefts, fa.focus).concat(pipeable_1.pipe(fa.rights, A.takeLeft(i))), a, pipeable_1.pipe(fa.rights, A.dropLeft(i + 1))));
        });
        return make(lefts, f(fa), rights);
    },
    extract: function (fa) { return fa.focus; },
    reduce: function (fa, b, f) { return fa.rights.reduce(f, f(fa.lefts.reduce(f, b), fa.focus)); },
    reduceRight: function (fa, b, f) {
        var rights = fa.rights.reduceRight(function (acc, a) { return f(a, acc); }, b);
        var focus = f(fa.focus, rights);
        return fa.lefts.reduceRight(function (acc, a) { return f(a, acc); }, focus);
    },
    foldMap: function (M) { return function (fa, f) {
        var lefts = fa.lefts.reduce(function (acc, a) { return M.concat(acc, f(a)); }, M.empty);
        var rights = fa.rights.reduce(function (acc, a) { return M.concat(acc, f(a)); }, M.empty);
        return M.concat(M.concat(lefts, f(fa.focus)), rights);
    }; },
    traverse: traverse,
    sequence: sequence
};
var _a = pipeable_1.pipeable(exports.zipper), ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, duplicate = _a.duplicate, extend = _a.extend, foldMap = _a.foldMap, map = _a.map, reduce = _a.reduce, reduceRight = _a.reduceRight;
exports.ap = ap;
exports.apFirst = apFirst;
exports.apSecond = apSecond;
exports.duplicate = duplicate;
exports.extend = extend;
exports.foldMap = foldMap;
exports.map = map;
exports.reduce = reduce;
exports.reduceRight = reduceRight;
