/**
 * @since 0.1.14
 */
import { Alt1 } from "fp-ts/lib/Alt";
import * as O from "fp-ts/lib/Option";
import { Filterable1 } from "fp-ts/lib/Filterable";
import { IO } from "fp-ts/lib/IO";
import { Monad1 } from "fp-ts/lib/Monad";
import { MonadIO1 } from "fp-ts/lib/MonadIO";
import { Monoid } from "fp-ts/lib/Monoid";
import { Semigroup } from "fp-ts/lib/Semigroup";
import Option = O.Option;
import { IOEither } from "fp-ts/lib/IOEither";
declare module "fp-ts/lib/HKT" {
  interface URItoKind<A> {
    IOOption: IOOption<A>;
  }
}
/**
 * @since 0.1.14
 */
export declare const URI = "IOOption";
/**
 * @since 0.1.14
 */
export declare type URI = typeof URI;
/**
 * @since 0.1.14
 */
export interface IOOption<A> extends IO<Option<A>> {}
/**
 * @since 0.1.14
 */
export declare const none: IOOption<never>;
/**
 * @since 0.1.14
 */
export declare const some: <A = never>(a: A) => IOOption<A>;
/**
 * @since 0.1.14
 */
export declare const fromIO: <A = never>(ma: IO<A>) => IOOption<A>;
/**
 * @since 0.1.14
 */
export declare const fromOption: <A = never>(ma: Option<A>) => IOOption<A>;
/**
 * @since 0.1.14
 */
export declare function fold<A, B>(
  onNone: () => IO<B>,
  onSome: (a: A) => IO<B>
): (ma: IOOption<A>) => IO<B>;
/**
 * @since 0.1.14
 */
export declare function fromNullable<A>(a: A): IOOption<NonNullable<A>>;
/**
 * @since 0.1.14
 */
export declare function getOrElse<A>(
  onNone: () => IO<A>
): (ma: IOOption<A>) => IO<A>;
/**
 * @since 0.1.14
 */
export declare function fromIOEither<A>(ma: IOEither<any, A>): IOOption<A>;
/**
 * @since 0.1.14
 */
export declare function toUndefined<A>(ma: IOOption<A>): IO<A | undefined>;
/**
 * @since 0.1.14
 */
export declare function toNullable<A>(ma: IOOption<A>): IO<A | null>;
/**
 * @since 0.1.14
 */
export declare function mapNullable<A, B>(
  f: (a: A) => B | null | undefined
): (ma: IOOption<A>) => IOOption<B>;
/**
 * @since 0.1.14
 */
export declare function getApplySemigroup<A>(
  S: Semigroup<A>
): Semigroup<IOOption<A>>;
/**
 * @since 0.1.14
 */
export declare function getApplyMonoid<A>(M: Monoid<A>): Monoid<IOOption<A>>;
/**
 * @since 0.1.14
 */
export declare function fromOptionK<A extends Array<unknown>, B>(
  f: (...a: A) => Option<B>
): (...a: A) => IOOption<B>;
/**
 * @since 0.1.14
 */
export declare function chainOptionK<A, B>(
  f: (a: A) => Option<B>
): (ma: IOOption<A>) => IOOption<B>;
/**
 * @since 0.1.14
 */
export declare const ioOption: Monad1<URI> &
  Alt1<URI> &
  MonadIO1<URI> &
  Filterable1<URI>;
declare const alt: <A>(
    that: () => IOOption<A>
  ) => (fa: IOOption<A>) => IOOption<A>,
  ap: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>,
  apFirst: <B>(fb: IOOption<B>) => <A>(fa: IOOption<A>) => IOOption<A>,
  apSecond: <B>(fb: IOOption<B>) => <A>(fa: IOOption<A>) => IOOption<B>,
  chain: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B>,
  chainFirst: <A, B>(
    f: (a: A) => IOOption<B>
  ) => (ma: IOOption<A>) => IOOption<A>,
  flatten: <A>(mma: IOOption<IOOption<A>>) => IOOption<A>,
  map: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B>,
  partition: {
    <A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>
    ): (
      fa: IOOption<A>
    ) => import("fp-ts/lib/Compactable").Separated<IOOption<A>, IOOption<B>>;
    <A_1>(predicate: import("fp-ts/lib/function").Predicate<A_1>): (
      fa: IOOption<A_1>
    ) => import("fp-ts/lib/Compactable").Separated<
      IOOption<A_1>,
      IOOption<A_1>
    >;
  },
  partitionMap: <A, B, C>(
    f: (a: A) => import("fp-ts/lib/Either").Either<B, C>
  ) => (
    fa: IOOption<A>
  ) => import("fp-ts/lib/Compactable").Separated<IOOption<B>, IOOption<C>>,
  filter: {
    <A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>
    ): (fa: IOOption<A>) => IOOption<B>;
    <A_1>(predicate: import("fp-ts/lib/function").Predicate<A_1>): (
      fa: IOOption<A_1>
    ) => IOOption<A_1>;
  },
  filterMap: <A, B>(
    f: (a: A) => O.Option<B>
  ) => (fa: IOOption<A>) => IOOption<B>,
  compact: <A>(fa: IOOption<O.Option<A>>) => IOOption<A>,
  separate: <A, B>(
    fa: IOOption<import("fp-ts/lib/Either").Either<A, B>>
  ) => import("fp-ts/lib/Compactable").Separated<IOOption<A>, IOOption<B>>;
export {
  /**
   * @since 0.1.14
   */
  alt,
  /**
   * @since 0.1.14
   */
  ap,
  /**
   * @since 0.1.14
   */
  apFirst,
  /**
   * @since 0.1.14
   */
  apSecond,
  /**
   * @since 0.1.14
   */
  chain,
  /**
   * @since 0.1.14
   */
  chainFirst,
  /**
   * @since 0.1.14
   */
  flatten,
  /**
   * @since 0.1.14
   */
  map,
  /**
   * @since 0.1.14
   */
  partition,
  /**
   * @since 0.1.14
   */
  partitionMap,
  /**
   * @since 0.1.14
   */
  filter,
  /**
   * @since 0.1.14
   */
  filterMap,
  /**
   * @since 0.1.14
   */
  compact,
  /**
   * @since 0.1.14
   */
  separate
};
