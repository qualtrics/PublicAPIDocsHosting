"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var A = require("fp-ts/lib/Array");
var O = require("fp-ts/lib/Option");
var pipeable_1 = require("fp-ts/lib/pipeable");
/**
 * @since 0.1.8
 */
exports.URI = 'List';
/**
 * @since 0.1.8
 */
exports.nil = { type: 'Nil', length: 0 };
/**
 * Attaches an element to the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.cons('a', L.nil), { type: 'Cons', head: 'a', tail: L.nil, length: 1 })
 *
 * @since 0.1.8
 */
function cons(head, tail) {
    return { type: 'Cons', head: head, tail: tail, length: 1 + tail.length };
}
exports.cons = cons;
/**
 * Creates a list with a single element.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.of('a'), L.cons('a', L.nil))
 *
 * @since 0.1.8
 */
function of(head) {
    return cons(head, exports.nil);
}
exports.of = of;
/**
 * Tests whether a list is an empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.strictEqual(L.isNil(L.nil), true)
 * assert.strictEqual(L.isNil(L.of(6)), false)
 *
 * @since 0.1.8
 */
function isNil(a) {
    return a.type === 'Nil';
}
exports.isNil = isNil;
/**
 * Tests whether a list is a non empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.strictEqual(L.isCons(L.nil), false)
 * assert.strictEqual(L.isCons(L.of(1)), true)
 *
 * @since 0.1.8
 */
function isCons(a) {
    return a.type === 'Cons';
}
exports.isCons = isCons;
/**
 * Gets the first element in a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/lib/Option'
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.head(L.nil), O.none)
 * assert.deepStrictEqual(L.head(L.cons('x', L.of('a'))), O.some('x'))
 *
 * @since 0.1.8
 */
function head(fa) {
    return isCons(fa) ? O.some(fa.head) : O.none;
}
exports.head = head;
/**
 * Gets all but the first element of a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/lib/Option'
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.tail(L.nil), O.none)
 * assert.deepStrictEqual(L.tail(L.of('a')), O.some(L.nil))
 * assert.deepStrictEqual(L.tail(L.cons('x', L.of('a'))), O.some(L.of('a')))
 *
 * @since 0.1.8
 */
function tail(fa) {
    return isCons(fa) ? O.some(fa.tail) : O.none;
}
exports.tail = tail;
/**
 * Breaks a list into its first element and the remaining elements.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * const len: <A>(as: L.List<A>) => number = L.foldLeft(
 *   () => 0,
 *   (_, tail) => 1 + len(tail)
 * )
 * assert.deepStrictEqual(len(L.cons('a', L.of('b'))), 2)
 * @since 0.1.8
 */
function foldLeft(onNil, onCons) {
    return function (fa) { return (isNil(fa) ? onNil() : onCons(fa.head, fa.tail)); };
}
exports.foldLeft = foldLeft;
/**
 * Finds the first index for which a predicate holds.
 *
 * @example
 * import * as O from 'fp-ts/lib/Option'
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * const f = (a: number): boolean => a % 2 === 0
 * const findIndexEven = L.findIndex(f)
 * assert.deepStrictEqual(findIndexEven(L.nil), O.none)
 * assert.deepStrictEqual(findIndexEven(L.cons(1, L.of(2))), O.some(1))
 * assert.deepStrictEqual(findIndexEven(L.of(1)), O.none)
 *
 * @since 0.1.8
 */
function findIndex(predicate) {
    return function (fa) {
        var l = fa;
        var i = 0;
        while (isCons(l)) {
            if (predicate(l.head))
                return O.some(i);
            l = l.tail;
            i++;
        }
        return O.none;
    };
}
exports.findIndex = findIndex;
/**
 * Reverse a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.reverse(L.cons(1, L.cons(2, L.of(3)))), L.cons(3, L.cons(2, L.of(1))))
 *
 * @since 0.1.8
 */
function reverse(fa) {
    var out = exports.nil;
    var l = fa;
    while (isCons(l)) {
        out = cons(l.head, out);
        l = l.tail;
    }
    return out;
}
exports.reverse = reverse;
/**
 * Drops the specified number of elements from the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.dropLeft(1)(L.nil), L.nil)
 * assert.deepStrictEqual(L.dropLeft(1)(L.cons(1, L.of(2))), L.of(2))
 * assert.deepStrictEqual(L.dropLeft(3)(L.cons(1, L.of(2))), L.nil)
 *
 * @since 0.1.8
 */
function dropLeft(n) {
    return function (fa) {
        if (isNil(fa))
            return exports.nil;
        var i = 0;
        var l = fa;
        while (isCons(l) && i < n) {
            i++;
            l = l.tail;
        }
        return l;
    };
}
exports.dropLeft = dropLeft;
function dropLeftWhile(predicate) {
    return function (fa) {
        if (isNil(fa))
            return exports.nil;
        var l = fa;
        while (isCons(l) && predicate(l.head)) {
            l = l.tail;
        }
        return l;
    };
}
exports.dropLeftWhile = dropLeftWhile;
/**
 * Gets an array from a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.toArray(L.cons('a', L.of('b'))), ['a', 'b'])
 *
 * @since 0.1.8
 */
function toArray(fa) {
    var length = fa.length;
    var out = new Array(length);
    var l = fa;
    for (var i = 0; i < length; i++) {
        out[i] = l.head;
        l = l.tail;
    }
    return out;
}
exports.toArray = toArray;
/**
 * Gets an array from a list in a reversed order.
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.toReversedArray(L.cons('a', L.of('b'))), ['b', 'a'])
 *
 * @since 0.1.8
 */
function toReversedArray(fa) {
    var length = fa.length;
    var out = new Array(length);
    var l = fa;
    for (var i = 0; i < length; i++) {
        out[length - i - 1] = l.head;
        l = l.tail;
    }
    return out;
}
exports.toReversedArray = toReversedArray;
/**
 * Creates a list from an array
 *
 * @example
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * assert.deepStrictEqual(L.fromArray([]), L.nil)
 * assert.deepStrictEqual(L.fromArray(['a', 'b']), L.cons('a', L.of('b')))
 *
 * @since 0.1.8
 */
function fromArray(as) {
    return A.array.reduceRight(as, exports.nil, cons);
}
exports.fromArray = fromArray;
/**
 * Derives an `Eq` over the `List` of a given element type from the `Eq` of that type.
 * The derived `Eq` defines two lists as equal if all elements of both lists
 * are compared equal pairwise with the given `E`. In case of lists of different
 * lengths, the result is non equality.
 *
 * @example
 * import { eqString } from 'fp-ts/lib/Eq'
 * import * as L from 'fp-ts-contrib/lib/List'
 *
 * const E = L.getEq(eqString)
 * assert.strictEqual(E.equals(L.cons('a', L.of('b')), L.cons('a', L.of('b'))), true)
 * assert.strictEqual(E.equals(L.of('x'), L.nil), false)
 *
 * @since 0.1.8
 */
function getEq(E) {
    return {
        equals: function (x, y) {
            if (x.length !== y.length)
                return false;
            var lx = x;
            var ly = y;
            while (isCons(lx) && isCons(ly)) {
                if (!E.equals(lx.head, ly.head))
                    return false;
                lx = lx.tail;
                ly = ly.tail;
            }
            return true;
        }
    };
}
exports.getEq = getEq;
/**
 * @since 0.1.8
 */
exports.list = {
    URI: exports.URI,
    map: function (fa, f) { return exports.list.reduceRight(fa, exports.nil, function (a, b) { return cons(f(a), b); }); },
    reduce: function (fa, b, f) {
        var out = b;
        var l = fa;
        while (isCons(l)) {
            out = f(out, l.head);
            l = l.tail;
        }
        return out;
    },
    foldMap: function (M) { return function (fa, f) {
        var out = M.empty;
        var l = fa;
        while (isCons(l)) {
            out = M.concat(out, f(l.head));
            l = l.tail;
        }
        return out;
    }; },
    reduceRight: function (fa, b, f) { return A.array.reduceRight(toArray(fa), b, f); },
    traverse: function (F) {
        return function (ta, f) {
            return exports.list.reduceRight(ta, F.of(exports.nil), function (a, fbs) {
                return F.ap(F.map(fbs, function (bs) { return function (b) { return cons(b, bs); }; }), f(a));
            });
        };
    },
    sequence: function (F) { return function (ta) {
        return exports.list.reduceRight(ta, F.of(exports.nil), function (a, fas) {
            return F.ap(F.map(fas, function (as) { return function (a) { return cons(a, as); }; }), a);
        });
    }; }
};
var _a = pipeable_1.pipeable(exports.list), map = _a.map, reduce = _a.reduce, foldMap = _a.foldMap, reduceRight = _a.reduceRight;
exports.map = map;
exports.reduce = reduce;
exports.foldMap = foldMap;
exports.reduceRight = reduceRight;
