/**
 * @since 0.1.12
 */
import * as E from "fp-ts/lib/Either";
import { Monad3 } from "fp-ts/lib/Monad";
import { MonadThrow3 } from "fp-ts/lib/MonadThrow";
import { State } from "fp-ts/lib/State";
declare module "fp-ts/lib/HKT" {
  interface URItoKind3<R, E, A> {
    StateEither: StateEither<R, E, A>;
  }
}
/**
 * @since 0.1.12
 */
export declare const URI = "StateEither";
/**
 * @since 0.1.12
 */
export declare type URI = typeof URI;
/**
 * @since 0.1.12
 */
export interface StateEither<S, E, A> {
  (s: S): E.Either<E, [A, S]>;
}
/**
 * @since 0.1.12
 */
export declare const evalState: <S, E, A>(
  ma: StateEither<S, E, A>,
  s: S
) => E.Either<E, A>;
/**
 * @since 0.1.12
 */
export declare const execState: <S, E, A>(
  ma: StateEither<S, E, A>,
  s: S
) => E.Either<E, S>;
/**
 * @since 0.1.12
 */
export declare function left<S, E, A = never>(e: E): StateEither<S, E, A>;
/**
 * @since 0.1.12
 */
export declare const right: <S, E = never, A = never>(
  a: A
) => StateEither<S, E, A>;
/**
 * @since 0.1.12
 */
export declare const rightState: <S, E = never, A = never>(
  ma: State<S, A>
) => StateEither<S, E, A>;
/**
 * @since 0.1.12
 */
export declare function leftState<S, E = never, A = never>(
  me: State<S, E>
): StateEither<S, E, A>;
/**
 * @since 0.1.12
 */
export declare const get: <S, E = never>() => StateEither<S, E, S>;
/**
 * @since 0.1.12
 */
export declare const put: <S, E = never>(s: S) => StateEither<S, E, void>;
/**
 * @since 0.1.12
 */
export declare const modify: <S, E = never>(
  f: (s: S) => S
) => StateEither<S, E, void>;
/**
 * @since 0.1.12
 */
export declare const gets: <S, E = never, A = never>(
  f: (s: S) => A
) => StateEither<S, E, A>;
/**
 * @since 0.1.0
 */
export declare const fromEither: <S, E, A>(
  ma: E.Either<E, A>
) => StateEither<S, E, A>;
/**
 * @since 0.1.12
 */
export declare function fromEitherK<E, A extends Array<unknown>, B>(
  f: (...a: A) => E.Either<E, B>
): <S>(...a: A) => StateEither<S, E, B>;
/**
 * @since 0.1.12
 */
export declare function chainEitherK<E, A, B>(
  f: (a: A) => E.Either<E, B>
): <S>(ma: StateEither<S, E, A>) => StateEither<S, E, B>;
/**
 * @since 0.1.12
 */
export declare const stateEither: Monad3<URI> & MonadThrow3<URI>;
declare const ap: <R, E, A>(
    fa: StateEither<R, E, A>
  ) => <B>(fab: StateEither<R, E, (a: A) => B>) => StateEither<R, E, B>,
  apFirst: <R, E, B>(
    fb: StateEither<R, E, B>
  ) => <A>(fa: StateEither<R, E, A>) => StateEither<R, E, A>,
  apSecond: <R, E, B>(
    fb: StateEither<R, E, B>
  ) => <A>(fa: StateEither<R, E, A>) => StateEither<R, E, B>,
  chain: <R, E, A, B>(
    f: (a: A) => StateEither<R, E, B>
  ) => (ma: StateEither<R, E, A>) => StateEither<R, E, B>,
  chainFirst: <R, E, A, B>(
    f: (a: A) => StateEither<R, E, B>
  ) => (ma: StateEither<R, E, A>) => StateEither<R, E, A>,
  flatten: <R, E, A>(
    mma: StateEither<R, E, StateEither<R, E, A>>
  ) => StateEither<R, E, A>,
  map: <A, B>(
    f: (a: A) => B
  ) => <R, E>(fa: StateEither<R, E, A>) => StateEither<R, E, B>,
  filterOrElse: {
    <E, A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>,
      onFalse: (a: A) => E
    ): <R>(ma: StateEither<R, E, A>) => StateEither<R, E, B>;
    <E_1, A_1>(
      predicate: import("fp-ts/lib/function").Predicate<A_1>,
      onFalse: (a: A_1) => E_1
    ): <R_1>(ma: StateEither<R_1, E_1, A_1>) => StateEither<R_1, E_1, A_1>;
  },
  fromOption: <E>(
    onNone: () => E
  ) => <R, A>(ma: import("fp-ts/lib/Option").Option<A>) => StateEither<R, E, A>,
  fromPredicate: {
    <E, A, B extends A>(
      refinement: import("fp-ts/lib/function").Refinement<A, B>,
      onFalse: (a: A) => E
    ): <U>(a: A) => StateEither<U, E, B>;
    <E_1, A_1>(
      predicate: import("fp-ts/lib/function").Predicate<A_1>,
      onFalse: (a: A_1) => E_1
    ): <R>(a: A_1) => StateEither<R, E_1, A_1>;
  };
export {
  /**
   * @since 0.1.12
   */
  ap,
  /**
   * @since 0.1.12
   */
  apFirst,
  /**
   * @since 0.1.12
   */
  apSecond,
  /**
   * @since 0.1.12
   */
  chain,
  /**
   * @since 0.1.12
   */
  chainFirst,
  /**
   * @since 0.1.12
   */
  flatten,
  /**
   * @since 0.1.12
   */
  map,
  /**
   * @since 0.1.12
   */
  filterOrElse,
  /**
   * @since 0.1.12
   */
  fromOption,
  /**
   * @since 0.1.12
   */
  fromPredicate
};
