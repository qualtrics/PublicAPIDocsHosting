/**
 * @since 0.1.0
 */
import { left, right, both } from 'fp-ts/es6/These';
import { array, URI } from 'fp-ts/es6/Array';
import { option } from 'fp-ts/es6/Option';
import { identity, tuple } from 'fp-ts/es6/function';
import { padZipWith } from './';
/**
 * `Align` instance for `Array`.
 *
 * @since 0.1.0
 */
export var alignArray = {
    URI: URI,
    map: array.map,
    /**
     * Unit value in regards to `align`
     */
    nil: function () { return []; },
    /**
     * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array.
     * Uses the `These` data type to handle arrays of different lengths.
     *
     * @example
     * import { These } from 'fp-ts/es6/These'
     * import { identity } from 'fp-ts/es6/function'
     * import { alignArray } from 'fp-ts-contrib/es6/Align/Array'
     *
     * const f = (x: These<number, string>) => x.fold(a => a.toString(), identity, (a, b) => a + b)
     *
     * assert.deepStrictEqual(alignArray.alignWith([1, 2], ['a', 'b'], f), ['1a', '2b'])
     * assert.deepStrictEqual(alignArray.alignWith([1, 2], ['a'], f), ['1a', '2'])
     * assert.deepStrictEqual(alignArray.alignWith([1], ['a' 'b'], f), ['1a', 'b'])
     *
     * @since 0.1.0
     */
    alignWith: function (fa, fb, f) {
        var fc = [];
        var aLen = fa.length;
        var bLen = fb.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
            fc[i] = f(both(fa[i], fb[i]));
        }
        if (aLen > bLen) {
            for (var i = bLen; i < aLen; i++) {
                fc[i] = f(left(fa[i]));
            }
        }
        else {
            for (var i = aLen; i < bLen; i++) {
                fc[i] = f(right(fb[i]));
            }
        }
        return fc;
    },
    /**
     * Takes two arrays and returns an array of corresponding pairs combined using the `These` data type.
     *
     * @example
     * import { These } from 'fp-ts/es6/These'
     * import { identity } from 'fp-ts/es6/function'
     * import { alignArray } from 'fp-ts-contrib/es6/Align/Array'
     *
     * assert.deepStrictEqual(alignArray.align([1, 2], ['a', 'b']), [both(1, 'a'), both(2, 'b')])
     * assert.deepStrictEqual(alignArray.align([1, 2], ['a']), [both(1, 'a'), left(2)])
     * assert.deepStrictEqual(alignArray.align([1], ['a' 'b']), [both(1, 'a'), right('b')])
     *
     * @since 0.1.0
     */
    align: function (fa, fb) {
        return alignArray.alignWith(fa, fb, identity);
    }
};
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the
 * left input array is short, it will be padded using `none`.
 *
 * It is similar to `zipWith`, but it doesn't discard elements when the left input array is shorter than the right.
 *
 * @example
 * import * as O from 'fp-ts/es6/Option'
 * import { lpadZipWith } from 'fp-ts-contrib/es6/Align/Array'
 * import { pipe } from 'fp-ts/es6/pipeable'
 *
 * const f = (ma: O.Option<number>, b: string) =>
 *   pipe(
 *     ma,
 *     O.fold(() => '*', a => a.toString())
 *   ) + b
 * assert.deepStrictEqual(lpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c', '*d'])
 * assert.deepStrictEqual(lpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c'])
 *
 * @since 0.1.0
 */
export function lpadZipWith(xs, ys, f) {
    return array.compact(padZipWith(alignArray)(xs, ys, function (ma, mb) { return option.map(mb, function (b) { return f(ma, b); }); }));
}
/**
 * Takes two arrays and returns an array of corresponding pairs. If the left input array is short, it will be
 * padded using `none`.
 *
 * It is similar to `zip`, but it doesn't discard elements when the left input array is shorter than the right.
 *
 * @example
 * import { some, none } from 'fp-ts/es6/Option'
 * import { lpadZip } from 'fp-ts-contrib/es6/Align/Array'
 *
 * assert.deepStrictEqual(lpadZip([1, 2], ['a', 'b', 'c']), [[some(1), 'a'], [some(2), 'b'], [none, 'c']])
 * assert.deepStrictEqual(lpadZip([1, 2, 3], ['a', 'b']), [[some(1), 'a'], [some(2), 'b']])
 *
 * @since 0.1.0
 */
export function lpadZip(xs, ys) {
    return lpadZipWith(xs, ys, function (a, b) { return tuple(a, b); });
}
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the
 * right input array is short, it will be padded using `none`.
 *
 * It is similar to `zipWith`, but it doesn't discard elements when the right input array is shorter than the left.
 *
 * @example
 * import { Option, getOrElse } from 'fp-ts/es6/Option'
 * import { rpadZipWith } from 'fp-ts-contrib/es6/Align/Array'
 *
 * const f = (a: number, mb: Option<string>) => a.toString() + getOrElse(() => '*')(mb)
 * assert.deepStrictEqual(rpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c', '4*'])
 * assert.deepStrictEqual(rpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c'])
 *
 * @since 0.1.0
 */
export function rpadZipWith(xs, ys, f) {
    return lpadZipWith(ys, xs, function (a, b) { return f(b, a); });
}
/**
 * Takes two arrays and returns an array of corresponding pairs. If the right input array is short, it will be
 * padded using `none`.
 *
 * It is similar to `zip`, but it doesn't discard elements when the right input array is shorter than the left.
 *
 * @example
 * import { some, none } from 'fp-ts/es6/Option'
 * import { rpadZip } from 'fp-ts-contrib/es6/Align/Array'
 *
 * assert.deepStrictEqual(rpadZip([1, 2, 3], ['a', 'b']), [[1, some('a')], [2, some('b')], [3, none]])
 * assert.deepStrictEqual(rpadZip([1, 2], ['a', 'b', 'c']), [[1, some('a')], [2, some('b')]])
 *
 * @since 0.1.0
 */
export function rpadZip(xs, ys) {
    return rpadZipWith(xs, ys, function (a, b) { return tuple(a, b); });
}
