import { URI } from "fp-ts/es6/Array";
import { Option } from "fp-ts/es6/Option";
import { Align1 } from "./";
/**
 * `Align` instance for `Array`.
 *
 * @since 0.1.0
 */
export declare const alignArray: Align1<URI>;
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the
 * left input array is short, it will be padded using `none`.
 *
 * It is similar to `zipWith`, but it doesn't discard elements when the left input array is shorter than the right.
 *
 * @example
 * import * as O from 'fp-ts/es6/Option'
 * import { lpadZipWith } from 'fp-ts-contrib/es6/Align/Array'
 * import { pipe } from 'fp-ts/es6/pipeable'
 *
 * const f = (ma: O.Option<number>, b: string) =>
 *   pipe(
 *     ma,
 *     O.fold(() => '*', a => a.toString())
 *   ) + b
 * assert.deepStrictEqual(lpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c', '*d'])
 * assert.deepStrictEqual(lpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c'])
 *
 * @since 0.1.0
 */
export declare function lpadZipWith<A, B, C>(
  xs: Array<A>,
  ys: Array<B>,
  f: (a: Option<A>, b: B) => C
): Array<C>;
/**
 * Takes two arrays and returns an array of corresponding pairs. If the left input array is short, it will be
 * padded using `none`.
 *
 * It is similar to `zip`, but it doesn't discard elements when the left input array is shorter than the right.
 *
 * @example
 * import { some, none } from 'fp-ts/es6/Option'
 * import { lpadZip } from 'fp-ts-contrib/es6/Align/Array'
 *
 * assert.deepStrictEqual(lpadZip([1, 2], ['a', 'b', 'c']), [[some(1), 'a'], [some(2), 'b'], [none, 'c']])
 * assert.deepStrictEqual(lpadZip([1, 2, 3], ['a', 'b']), [[some(1), 'a'], [some(2), 'b']])
 *
 * @since 0.1.0
 */
export declare function lpadZip<A, B>(
  xs: Array<A>,
  ys: Array<B>
): Array<[Option<A>, B]>;
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the
 * right input array is short, it will be padded using `none`.
 *
 * It is similar to `zipWith`, but it doesn't discard elements when the right input array is shorter than the left.
 *
 * @example
 * import { Option, getOrElse } from 'fp-ts/es6/Option'
 * import { rpadZipWith } from 'fp-ts-contrib/es6/Align/Array'
 *
 * const f = (a: number, mb: Option<string>) => a.toString() + getOrElse(() => '*')(mb)
 * assert.deepStrictEqual(rpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c', '4*'])
 * assert.deepStrictEqual(rpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c'])
 *
 * @since 0.1.0
 */
export declare function rpadZipWith<A, B, C>(
  xs: Array<A>,
  ys: Array<B>,
  f: (a: A, b: Option<B>) => C
): Array<C>;
/**
 * Takes two arrays and returns an array of corresponding pairs. If the right input array is short, it will be
 * padded using `none`.
 *
 * It is similar to `zip`, but it doesn't discard elements when the right input array is shorter than the left.
 *
 * @example
 * import { some, none } from 'fp-ts/es6/Option'
 * import { rpadZip } from 'fp-ts-contrib/es6/Align/Array'
 *
 * assert.deepStrictEqual(rpadZip([1, 2, 3], ['a', 'b']), [[1, some('a')], [2, some('b')], [3, none]])
 * assert.deepStrictEqual(rpadZip([1, 2], ['a', 'b', 'c']), [[1, some('a')], [2, some('b')]])
 *
 * @since 0.1.0
 */
export declare function rpadZip<A, B>(
  xs: Array<A>,
  ys: Array<B>
): Array<[A, Option<B>]>;
