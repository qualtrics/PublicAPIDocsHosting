var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as A from 'fp-ts/es6/Array';
import { decrement, increment } from 'fp-ts/es6/function';
import { none, some } from 'fp-ts/es6/Option';
import { pipe, pipeable } from 'fp-ts/es6/pipeable';
/**
 * @since 0.1.6
 */
export var URI = 'Zipper';
/**
 * Creates a new zipper.
 * @since 0.1.6
 */
export function make(lefts, focus, rights) {
    return { lefts: lefts, focus: focus, rights: rights };
}
/**
 * @since 0.1.6
 */
export function length(fa) {
    return fa.lefts.length + 1 + fa.rights.length;
}
/**
 * Updates the focus of the zipper.
 * @since 0.1.6
 */
export function update(a) {
    return function (fa) { return make(fa.lefts, a, fa.rights); };
}
/**
 * Applies `f` to the focus and update with the result.
 * @since 0.1.6
 */
export function modify(f) {
    return function (fa) { return pipe(fa, update(f(fa.focus))); };
}
/**
 * @since 0.1.6
 */
export function toArray(fa) {
    return A.snoc(fa.lefts, fa.focus).concat(fa.rights);
}
/**
 * @since 0.1.6
 */
export function isOutOfBound(index, fa) {
    return index < 0 || index >= length(fa);
}
/**
 * Moves focus in the zipper, or `None` if there is no such element.
 * @since 0.1.6
 */
export function move(f, fa) {
    var newIndex = f(fa.lefts.length);
    if (isOutOfBound(newIndex, fa)) {
        return none;
    }
    else {
        return fromArray(toArray(fa), newIndex);
    }
}
/**
 * Moves focus of the zipper up.
 * @since 0.1.6
 */
export function up(fa) {
    return move(decrement, fa);
}
/**
 * Moves focus of the zipper down.
 * @since 0.1.6
 */
export function down(fa) {
    return move(increment, fa);
}
/**
 * Moves focus to the start of the zipper.
 * @since 0.1.6
 */
export function start(fa) {
    if (A.isEmpty(fa.lefts)) {
        return fa;
    }
    else {
        return make(A.empty, fa.lefts[0], A.snoc(pipe(fa.lefts, A.dropLeft(1)), fa.focus).concat(fa.rights));
    }
}
/**
 * Moves focus to the end of the zipper.
 * @since 0.1.6
 */
export function end(fa) {
    var len = fa.rights.length;
    if (len === 0) {
        return fa;
    }
    else {
        return make(A.snoc(fa.lefts, fa.focus).concat(pipe(fa.rights, A.takeLeft(len - 1))), fa.rights[len - 1], A.empty);
    }
}
/**
 * Inserts an element to the left of the focus and focuses on the new element.
 * @since 0.1.6
 */
export function insertLeft(a) {
    return function (fa) { return make(fa.lefts, a, A.cons(fa.focus, fa.rights)); };
}
/**
 * Inserts an element to the right of the focus and focuses on the new element.
 * @since 0.1.6
 */
export function insertRight(a) {
    return function (fa) { return make(A.snoc(fa.lefts, fa.focus), a, fa.rights); };
}
/**
 * Deletes the element at focus and moves the focus to the left. If there is no element on the left,
 * the focus is moved to the right.
 * @since 0.1.6
 */
export function deleteLeft(fa) {
    var len = fa.lefts.length;
    return fromArray(fa.lefts.concat(fa.rights), len > 0 ? len - 1 : 0);
}
/**
 * Deletes the element at focus and moves the focus to the right. If there is no element on the right,
 * the focus is moved to the left.
 * @since 0.1.6
 */
export function deleteRight(fa) {
    var lenl = fa.lefts.length;
    var lenr = fa.rights.length;
    return fromArray(fa.lefts.concat(fa.rights), lenr > 0 ? lenl : lenl - 1);
}
/**
 * @since 0.1.6
 */
export function getShow(S) {
    var SA = A.getShow(S);
    return {
        show: function (fa) { return "Zipper(" + SA.show(fa.lefts) + ", " + S.show(fa.focus) + ", " + SA.show(fa.rights) + ")"; }
    };
}
/**
 * @since 0.1.6
 */
export function fromArray(as, focusIndex) {
    if (focusIndex === void 0) { focusIndex = 0; }
    if (A.isEmpty(as) || A.isOutOfBound(focusIndex, as)) {
        return none;
    }
    else {
        return some(make(pipe(as, A.takeLeft(focusIndex)), as[focusIndex], pipe(as, A.dropLeft(focusIndex + 1))));
    }
}
/**
 * @since 0.1.6
 */
export function fromNonEmptyArray(nea) {
    return make(A.empty, nea[0], nea.slice(1));
}
/**
 * @since 0.1.6
 */
export function of(focus) {
    return make(A.empty, focus, A.empty);
}
function traverse(F) {
    var traverseF = A.array.traverse(F);
    return function (ta, f) {
        return F.ap(F.ap(F.map(traverseF(ta.lefts, f), function (lefts) { return function (focus) { return function (rights) { return make(lefts, focus, rights); }; }; }), f(ta.focus)), traverseF(ta.rights, f));
    };
}
function sequence(F) {
    var sequenceF = A.array.sequence(F);
    return function (ta) {
        return F.ap(F.ap(F.map(sequenceF(ta.lefts), function (lefts) { return function (focus) { return function (rights) { return make(lefts, focus, rights); }; }; }), ta.focus), sequenceF(ta.rights));
    };
}
/**
 * @since 0.1.6
 */
export function getSemigroup(S) {
    return {
        concat: function (x, y) { return make(x.lefts.concat(y.lefts), S.concat(x.focus, y.focus), x.rights.concat(y.rights)); }
    };
}
/**
 * @since 0.1.6
 */
export function getMonoid(M) {
    return __assign(__assign({}, getSemigroup(M)), { empty: make(A.empty, M.empty, A.empty) });
}
/**
 * @since 0.1.6
 */
export var zipper = {
    URI: URI,
    map: function (z, f) { return make(z.lefts.map(f), f(z.focus), z.rights.map(f)); },
    of: of,
    ap: function (fab, fa) { return make(A.array.ap(fab.lefts, fa.lefts), fab.focus(fa.focus), A.array.ap(fab.rights, fa.rights)); },
    extend: function (fa, f) {
        var lefts = fa.lefts.map(function (a, i) {
            return f(make(pipe(fa.lefts, A.takeLeft(i)), a, A.snoc(pipe(fa.lefts, A.dropLeft(i + 1)), fa.focus).concat(fa.rights)));
        });
        var rights = fa.rights.map(function (a, i) {
            return f(make(A.snoc(fa.lefts, fa.focus).concat(pipe(fa.rights, A.takeLeft(i))), a, pipe(fa.rights, A.dropLeft(i + 1))));
        });
        return make(lefts, f(fa), rights);
    },
    extract: function (fa) { return fa.focus; },
    reduce: function (fa, b, f) { return fa.rights.reduce(f, f(fa.lefts.reduce(f, b), fa.focus)); },
    reduceRight: function (fa, b, f) {
        var rights = fa.rights.reduceRight(function (acc, a) { return f(a, acc); }, b);
        var focus = f(fa.focus, rights);
        return fa.lefts.reduceRight(function (acc, a) { return f(a, acc); }, focus);
    },
    foldMap: function (M) { return function (fa, f) {
        var lefts = fa.lefts.reduce(function (acc, a) { return M.concat(acc, f(a)); }, M.empty);
        var rights = fa.rights.reduce(function (acc, a) { return M.concat(acc, f(a)); }, M.empty);
        return M.concat(M.concat(lefts, f(fa.focus)), rights);
    }; },
    traverse: traverse,
    sequence: sequence
};
var _a = pipeable(zipper), ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, duplicate = _a.duplicate, extend = _a.extend, foldMap = _a.foldMap, map = _a.map, reduce = _a.reduce, reduceRight = _a.reduceRight;
export { 
/**
 * @since 0.1.6
 */
ap, 
/**
 * @since 0.1.11
 */
apFirst, 
/**
 * @since 0.1.11
 */
apSecond, 
/**
 * @since 0.1.11
 */
duplicate, 
/**
 * @since 0.1.11
 */
extend, 
/**
 * @since 0.1.11
 */
foldMap, 
/**
 * @since 0.1.6
 */
map, 
/**
 * @since 0.1.6
 */
reduce, 
/**
 * @since 0.1.6
 */
reduceRight };
