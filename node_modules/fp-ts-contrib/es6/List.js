import * as A from 'fp-ts/es6/Array';
import * as O from 'fp-ts/es6/Option';
import { pipeable } from 'fp-ts/es6/pipeable';
/**
 * @since 0.1.8
 */
export var URI = 'List';
/**
 * @since 0.1.8
 */
export var nil = { type: 'Nil', length: 0 };
/**
 * Attaches an element to the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.cons('a', L.nil), { type: 'Cons', head: 'a', tail: L.nil, length: 1 })
 *
 * @since 0.1.8
 */
export function cons(head, tail) {
    return { type: 'Cons', head: head, tail: tail, length: 1 + tail.length };
}
/**
 * Creates a list with a single element.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.of('a'), L.cons('a', L.nil))
 *
 * @since 0.1.8
 */
export function of(head) {
    return cons(head, nil);
}
/**
 * Tests whether a list is an empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.strictEqual(L.isNil(L.nil), true)
 * assert.strictEqual(L.isNil(L.of(6)), false)
 *
 * @since 0.1.8
 */
export function isNil(a) {
    return a.type === 'Nil';
}
/**
 * Tests whether a list is a non empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.strictEqual(L.isCons(L.nil), false)
 * assert.strictEqual(L.isCons(L.of(1)), true)
 *
 * @since 0.1.8
 */
export function isCons(a) {
    return a.type === 'Cons';
}
/**
 * Gets the first element in a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/es6/Option'
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.head(L.nil), O.none)
 * assert.deepStrictEqual(L.head(L.cons('x', L.of('a'))), O.some('x'))
 *
 * @since 0.1.8
 */
export function head(fa) {
    return isCons(fa) ? O.some(fa.head) : O.none;
}
/**
 * Gets all but the first element of a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/es6/Option'
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.tail(L.nil), O.none)
 * assert.deepStrictEqual(L.tail(L.of('a')), O.some(L.nil))
 * assert.deepStrictEqual(L.tail(L.cons('x', L.of('a'))), O.some(L.of('a')))
 *
 * @since 0.1.8
 */
export function tail(fa) {
    return isCons(fa) ? O.some(fa.tail) : O.none;
}
/**
 * Breaks a list into its first element and the remaining elements.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * const len: <A>(as: L.List<A>) => number = L.foldLeft(
 *   () => 0,
 *   (_, tail) => 1 + len(tail)
 * )
 * assert.deepStrictEqual(len(L.cons('a', L.of('b'))), 2)
 * @since 0.1.8
 */
export function foldLeft(onNil, onCons) {
    return function (fa) { return (isNil(fa) ? onNil() : onCons(fa.head, fa.tail)); };
}
/**
 * Finds the first index for which a predicate holds.
 *
 * @example
 * import * as O from 'fp-ts/es6/Option'
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * const f = (a: number): boolean => a % 2 === 0
 * const findIndexEven = L.findIndex(f)
 * assert.deepStrictEqual(findIndexEven(L.nil), O.none)
 * assert.deepStrictEqual(findIndexEven(L.cons(1, L.of(2))), O.some(1))
 * assert.deepStrictEqual(findIndexEven(L.of(1)), O.none)
 *
 * @since 0.1.8
 */
export function findIndex(predicate) {
    return function (fa) {
        var l = fa;
        var i = 0;
        while (isCons(l)) {
            if (predicate(l.head))
                return O.some(i);
            l = l.tail;
            i++;
        }
        return O.none;
    };
}
/**
 * Reverse a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.reverse(L.cons(1, L.cons(2, L.of(3)))), L.cons(3, L.cons(2, L.of(1))))
 *
 * @since 0.1.8
 */
export function reverse(fa) {
    var out = nil;
    var l = fa;
    while (isCons(l)) {
        out = cons(l.head, out);
        l = l.tail;
    }
    return out;
}
/**
 * Drops the specified number of elements from the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.dropLeft(1)(L.nil), L.nil)
 * assert.deepStrictEqual(L.dropLeft(1)(L.cons(1, L.of(2))), L.of(2))
 * assert.deepStrictEqual(L.dropLeft(3)(L.cons(1, L.of(2))), L.nil)
 *
 * @since 0.1.8
 */
export function dropLeft(n) {
    return function (fa) {
        if (isNil(fa))
            return nil;
        var i = 0;
        var l = fa;
        while (isCons(l) && i < n) {
            i++;
            l = l.tail;
        }
        return l;
    };
}
export function dropLeftWhile(predicate) {
    return function (fa) {
        if (isNil(fa))
            return nil;
        var l = fa;
        while (isCons(l) && predicate(l.head)) {
            l = l.tail;
        }
        return l;
    };
}
/**
 * Gets an array from a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.toArray(L.cons('a', L.of('b'))), ['a', 'b'])
 *
 * @since 0.1.8
 */
export function toArray(fa) {
    var length = fa.length;
    var out = new Array(length);
    var l = fa;
    for (var i = 0; i < length; i++) {
        out[i] = l.head;
        l = l.tail;
    }
    return out;
}
/**
 * Gets an array from a list in a reversed order.
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.toReversedArray(L.cons('a', L.of('b'))), ['b', 'a'])
 *
 * @since 0.1.8
 */
export function toReversedArray(fa) {
    var length = fa.length;
    var out = new Array(length);
    var l = fa;
    for (var i = 0; i < length; i++) {
        out[length - i - 1] = l.head;
        l = l.tail;
    }
    return out;
}
/**
 * Creates a list from an array
 *
 * @example
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * assert.deepStrictEqual(L.fromArray([]), L.nil)
 * assert.deepStrictEqual(L.fromArray(['a', 'b']), L.cons('a', L.of('b')))
 *
 * @since 0.1.8
 */
export function fromArray(as) {
    return A.array.reduceRight(as, nil, cons);
}
/**
 * Derives an `Eq` over the `List` of a given element type from the `Eq` of that type.
 * The derived `Eq` defines two lists as equal if all elements of both lists
 * are compared equal pairwise with the given `E`. In case of lists of different
 * lengths, the result is non equality.
 *
 * @example
 * import { eqString } from 'fp-ts/es6/Eq'
 * import * as L from 'fp-ts-contrib/es6/List'
 *
 * const E = L.getEq(eqString)
 * assert.strictEqual(E.equals(L.cons('a', L.of('b')), L.cons('a', L.of('b'))), true)
 * assert.strictEqual(E.equals(L.of('x'), L.nil), false)
 *
 * @since 0.1.8
 */
export function getEq(E) {
    return {
        equals: function (x, y) {
            if (x.length !== y.length)
                return false;
            var lx = x;
            var ly = y;
            while (isCons(lx) && isCons(ly)) {
                if (!E.equals(lx.head, ly.head))
                    return false;
                lx = lx.tail;
                ly = ly.tail;
            }
            return true;
        }
    };
}
/**
 * @since 0.1.8
 */
export var list = {
    URI: URI,
    map: function (fa, f) { return list.reduceRight(fa, nil, function (a, b) { return cons(f(a), b); }); },
    reduce: function (fa, b, f) {
        var out = b;
        var l = fa;
        while (isCons(l)) {
            out = f(out, l.head);
            l = l.tail;
        }
        return out;
    },
    foldMap: function (M) { return function (fa, f) {
        var out = M.empty;
        var l = fa;
        while (isCons(l)) {
            out = M.concat(out, f(l.head));
            l = l.tail;
        }
        return out;
    }; },
    reduceRight: function (fa, b, f) { return A.array.reduceRight(toArray(fa), b, f); },
    traverse: function (F) {
        return function (ta, f) {
            return list.reduceRight(ta, F.of(nil), function (a, fbs) {
                return F.ap(F.map(fbs, function (bs) { return function (b) { return cons(b, bs); }; }), f(a));
            });
        };
    },
    sequence: function (F) { return function (ta) {
        return list.reduceRight(ta, F.of(nil), function (a, fas) {
            return F.ap(F.map(fas, function (as) { return function (a) { return cons(a, as); }; }), a);
        });
    }; }
};
var _a = pipeable(list), map = _a.map, reduce = _a.reduce, foldMap = _a.foldMap, reduceRight = _a.reduceRight;
export { 
/**
 * @since 0.1.8
 */
map, 
/**
 * @since 0.1.8
 */
reduce, 
/**
 * @since 0.1.8
 */
foldMap, 
/**
 * @since 0.1.8
 */
reduceRight };
