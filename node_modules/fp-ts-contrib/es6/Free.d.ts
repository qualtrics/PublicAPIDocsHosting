/**
 * @since 0.1.3
 */
import { HKT, Kind, Kind2, Kind3, URIS, URIS2, URIS3 } from "fp-ts/es6/HKT";
import { Monad, Monad1, Monad2, Monad2C, Monad3 } from "fp-ts/es6/Monad";
/**
 * @since 0.1.3
 */
export declare const URI = "Free";
/**
 * @since 0.1.3
 */
export declare type URI = typeof URI;
declare module "fp-ts/es6/HKT" {
  interface URItoKind2<E, A> {
    Free: Free<E, A>;
  }
}
/**
 * @data
 * @constructor Pure
 * @constructor Impure
 * @since 0.1.3
 */
export declare type Free<F, A> = Pure<F, A> | Impure<F, A, any>;
interface Pure<_F, A> {
  readonly _tag: "Pure";
  readonly value: A;
}
interface Impure<F, A, X> {
  readonly _tag: "Impure";
  readonly fx: HKT<F, X>;
  readonly f: (x: X) => Free<F, A>;
}
/**
 * Check if given Free instance is Pure
 *
 * @since 0.1.3
 */
export declare const isPure: <F, A>(fa: Free<F, A>) => fa is Pure<F, A>;
/**
 * Check if given Free instance is Impure
 *
 * @since 0.1.3
 */
export declare const isImpure: <F, A>(
  fa: Free<F, A>
) => fa is Impure<F, A, any>;
/**
 * Lift an impure value described by the generating type constructor `F` into the free monad
 *
 * @since 0.1.3
 */
export declare const liftF: <F, A>(fa: HKT<F, A>) => Free<F, A>;
/**
 * Use a natural transformation to change the generating type constructor of a free monad
 *
 * @since 0.1.3
 */
export declare function hoistFree<
  F extends URIS3 = never,
  G extends URIS3 = never
>(
  nt: <U, L, A>(fa: Kind3<F, U, L, A>) => Kind3<G, U, L, A>
): <A>(fa: Free<F, A>) => Free<G, A>;
export declare function hoistFree<
  F extends URIS2 = never,
  G extends URIS2 = never
>(
  nt: <L, A>(fa: Kind2<F, L, A>) => Kind2<G, L, A>
): <A>(fa: Free<F, A>) => Free<G, A>;
export declare function hoistFree<
  F extends URIS = never,
  G extends URIS = never
>(nt: <A>(fa: Kind<F, A>) => Kind<G, A>): <A>(fa: Free<F, A>) => Free<G, A>;
export declare function hoistFree<F, G>(
  nt: <A>(fa: HKT<F, A>) => HKT<G, A>
): <A>(fa: Free<F, A>) => Free<G, A>;
/**
 * @since 0.1.3
 */
export interface FoldFree3<M extends URIS3> {
  <F extends URIS3, U, L, A>(
    nt: <X>(fa: Kind3<F, U, L, X>) => Kind3<M, U, L, X>,
    fa: Free<F, A>
  ): Kind3<M, U, L, A>;
  <F extends URIS2, U, L, A>(
    nt: <X>(fa: Kind2<F, L, X>) => Kind3<M, U, L, X>,
    fa: Free<F, A>
  ): Kind3<M, U, L, A>;
  <F extends URIS, U, L, A>(
    nt: <X>(fa: Kind<F, X>) => Kind3<M, U, L, X>,
    fa: Free<F, A>
  ): Kind3<M, U, L, A>;
}
/**
 * @since 0.1.3
 */
export interface FoldFree2<M extends URIS2> {
  <F extends URIS2, L, A>(
    nt: <X>(fa: Kind2<F, L, X>) => Kind2<M, L, X>,
    fa: Free<F, A>
  ): Kind2<M, L, A>;
  <F extends URIS, L, A>(
    nt: <X>(fa: Kind<F, X>) => Kind2<M, L, X>,
    fa: Free<F, A>
  ): Kind2<M, L, A>;
}
/**
 * @since 0.1.3
 */
export interface FoldFree2C<M extends URIS2, L> {
  <F extends URIS2, A>(
    nt: <X>(fa: Kind2<F, L, X>) => Kind2<M, L, X>,
    fa: Free<F, A>
  ): Kind2<M, L, A>;
  <F extends URIS, A>(
    nt: <X>(fa: Kind<F, X>) => Kind2<M, L, X>,
    fa: Free<F, A>
  ): Kind2<M, L, A>;
}
/**
 * Perform folding of a free monad using given natural transformation as an interpreter
 *
 * @since 0.1.3
 */
export declare function foldFree<M extends URIS3>(M: Monad3<M>): FoldFree3<M>;
export declare function foldFree<M extends URIS2>(M: Monad2<M>): FoldFree2<M>;
export declare function foldFree<M extends URIS2, L>(
  M: Monad2C<M, L>
): FoldFree2C<M, L>;
export declare function foldFree<M extends URIS>(
  M: Monad1<M>
): <F extends URIS, A>(
  nt: <X>(fa: Kind<F, X>) => Kind<M, X>,
  fa: Free<F, A>
) => Kind<M, A>;
export declare function foldFree<M>(
  M: Monad<M>
): <F, A>(nt: <X>(fa: HKT<F, X>) => HKT<M, X>, fa: Free<F, A>) => HKT<M, A>;
/**
 * Monad instance for Free
 *
 * @since 0.1.3
 */
export declare const free: Monad2<URI>;
declare const ap: <E, A>(
    fa: Free<E, A>
  ) => <B>(fab: Free<E, (a: A) => B>) => Free<E, B>,
  chain: <E, A, B>(f: (a: A) => Free<E, B>) => (ma: Free<E, A>) => Free<E, B>,
  map: <A, B>(f: (a: A) => B) => <E>(fa: Free<E, A>) => Free<E, B>,
  flatten: <E, A>(mma: Free<E, Free<E, A>>) => Free<E, A>;
export {
  /**
   * @since 0.1.3
   */
  ap,
  /**
   * @since 0.1.3
   */
  chain,
  /**
   * @since 0.1.3
   */
  map,
  /**
   * @since 0.1.3
   */
  flatten
};
