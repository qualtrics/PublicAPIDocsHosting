/**
 * @since 0.1.0
 */
import { Alt1 } from "fp-ts/es6/Alt";
import { Monad1 } from "fp-ts/es6/Monad";
import { Option } from "fp-ts/es6/Option";
declare module "fp-ts/es6/HKT" {
  interface URItoKind<A> {
    ArrayOption: ArrayOption<A>;
  }
}
/**
 * @since 0.1.0
 */
export declare const URI = "ArrayOption";
/**
 * @since 0.1.0
 */
export declare type URI = typeof URI;
/**
 * @since 0.1.0
 */
export interface ArrayOption<A> extends Array<Option<A>> {}
/**
 * @since 0.1.0
 */
export declare const fromArray: <A>(as: Array<A>) => ArrayOption<A>;
/**
 * @since 0.1.0
 */
export declare const fromOption: <A>(ma: Option<A>) => ArrayOption<A>;
/**
 * @since 0.1.0
 */
export declare const none: ArrayOption<never>;
/**
 * @since 0.1.0
 */
export declare const some: <A>(a: A) => ArrayOption<A>;
/**
 * @since 0.1.0
 */
export declare function fold<A, B>(
  onNone: () => Array<B>,
  onSome: (a: A) => Array<B>
): (as: ArrayOption<A>) => Array<B>;
/**
 * @since 0.1.0
 */
export declare function getOrElse<A>(
  onNone: () => Array<A>
): (as: ArrayOption<A>) => Array<A>;
/**
 * @since 0.1.10
 */
export declare function fromOptionK<A extends Array<unknown>, B>(
  f: (...a: A) => Option<B>
): (...a: A) => ArrayOption<B>;
/**
 * @since 0.1.10
 */
export declare function chainOptionK<A, B>(
  f: (a: A) => Option<B>
): (ma: ArrayOption<A>) => ArrayOption<B>;
/**
 * @since 0.1.0
 */
export declare const arrayOption: Monad1<URI> & Alt1<URI>;
declare const alt: <A>(
    that: () => ArrayOption<A>
  ) => (fa: ArrayOption<A>) => ArrayOption<A>,
  ap: <A>(
    fa: ArrayOption<A>
  ) => <B>(fab: ArrayOption<(a: A) => B>) => ArrayOption<B>,
  apFirst: <B>(fb: ArrayOption<B>) => <A>(fa: ArrayOption<A>) => ArrayOption<A>,
  apSecond: <B>(
    fb: ArrayOption<B>
  ) => <A>(fa: ArrayOption<A>) => ArrayOption<B>,
  chain: <A, B>(
    f: (a: A) => ArrayOption<B>
  ) => (ma: ArrayOption<A>) => ArrayOption<B>,
  chainFirst: <A, B>(
    f: (a: A) => ArrayOption<B>
  ) => (ma: ArrayOption<A>) => ArrayOption<A>,
  flatten: <A>(mma: ArrayOption<ArrayOption<A>>) => ArrayOption<A>,
  map: <A, B>(f: (a: A) => B) => (fa: ArrayOption<A>) => ArrayOption<B>;
export {
  /**
   * @since 0.1.0
   */
  alt,
  /**
   * @since 0.1.0
   */
  ap,
  /**
   * @since 0.1.0
   */
  apFirst,
  /**
   * @since 0.1.0
   */
  apSecond,
  /**
   * @since 0.1.0
   */
  chain,
  /**
   * @since 0.1.0
   */
  chainFirst,
  /**
   * @since 0.1.0
   */
  flatten,
  /**
   * @since 0.1.0
   */
  map
};
