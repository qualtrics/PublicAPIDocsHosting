import { IHttpConfig, IHttpOperationConfig } from '@stoplight/prism-http';
import * as PrismClient from '@stoplight/prism-http/dist/client';
import { IHttpOperation, IHttpRequest } from '@stoplight/types';
import { CancelTokenSource } from 'axios';
import { RequestStore } from './request';
import { ResponseStore } from './response';
export interface IRequestMakerStoreOptions {
    request?: Partial<IHttpRequest>;
    operation?: Partial<IHttpOperation>;
    validate?: boolean;
    mockUrl?: string;
}
export declare class RequestMakerStore {
    cancelToken?: CancelTokenSource;
    isSending: boolean;
    request: RequestStore;
    response: ResponseStore;
    private _originalOperation?;
    private _originalRequest?;
    constructor(options?: IRequestMakerStoreOptions);
    get hasChanges(): boolean;
    get operation(): Partial<IHttpOperation> | undefined;
    set operation(operation: Partial<IHttpOperation> | undefined);
    get prism(): PrismClient.PrismHttp;
    private get activePreferHeaders();
    get prismConfig(): Readonly<IHttpConfig>;
    get isMatchingOperation(): boolean;
    get isMockEnabled(): boolean;
    setOperationData: (operation: Partial<IHttpOperation>) => void;
    setRequestData: (request: Partial<IHttpRequest<any>>) => void;
    private setPreferHeaderOption;
    private removePreferHeaderOption;
    setPrismMockingOption: <T extends "code" | "mediaTypes" | "exampleKey" | "dynamic">(key: T, value: IHttpOperationConfig[T]) => void;
    setPrismConfigurationOption: <T extends "checkSecurity" | "validateRequest" | "validateResponse" | "errors">(key: T, value: IHttpConfig[T]) => void;
    mock: () => Promise<void>;
    send: () => Promise<void>;
    cancel(): void;
    reset(): void;
}
export declare function extractPrismPathFromRequestUrl(requestUrl: string, baseUrl: string): string;
