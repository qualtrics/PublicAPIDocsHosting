"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const urijs_1 = tslib_1.__importDefault(require("urijs"));
const params_1 = require("./params");
function addParamsToPath(path, params) {
    let newPath = path;
    const pathParamsFromPath = parsePathParams(path);
    const pathParamsWithName = lodash_1.filter(params, param => param.name !== '');
    const isRemoved = pathParamsWithName.length < pathParamsFromPath.length;
    if (isRemoved) {
        const diff = lodash_1.differenceBy(pathParamsFromPath, lodash_1.map(params, p => p.name));
        diff.forEach(d => {
            newPath = newPath.replace(`/{${d}}`, '');
        });
    }
    else {
        pathParamsWithName.forEach((p, i) => {
            if (pathParamsFromPath[i]) {
                newPath = newPath.replace(`{${pathParamsFromPath[i]}}`, `{${p.name}}`);
            }
            else {
                newPath = `${newPath}/{${p.name}}`;
            }
        });
    }
    return newPath;
}
exports.addParamsToPath = addParamsToPath;
function getParamsFromPath(path, params) {
    const pathParamsFromPath = parsePathParams(path);
    let pathParamsWithName = lodash_1.filter(params, param => param.name !== '');
    const isRemoved = pathParamsFromPath.length < pathParamsWithName.length;
    if (isRemoved) {
        const diff = lodash_1.differenceBy(pathParamsWithName.map(p => p.name), pathParamsFromPath);
        pathParamsWithName = pathParamsWithName.filter(p => !diff.includes(p.name));
    }
    const newParams = pathParamsFromPath.map((p, i) => (Object.assign(Object.assign(Object.assign({}, pathParamsWithName[i]), { name: p }), (i > pathParamsWithName.length - 1 && {
        isEnabled: true,
        value: '',
    }))));
    return newParams;
}
exports.getParamsFromPath = getParamsFromPath;
function parsePathParams(path = '') {
    const pathParams = path.match(/{[^{}]+}/g);
    if (pathParams && pathParams.length) {
        return pathParams.map(p => p.slice(1, -1));
    }
    else {
        return [];
    }
}
function uriExpand(uri, data) {
    if (!data) {
        return uri;
    }
    return uri.replace(/{([^#?]+?)}/g, (m, value) => {
        return data[value] || value;
    });
}
function replaceParamsInPath(path, pathParams) {
    let uri = path;
    try {
        uri = uriExpand(path, params_1.getNameValuePairs(pathParams, { enabled: true }));
    }
    catch (err) {
    }
    return uri;
}
exports.replaceParamsInPath = replaceParamsInPath;
function extractQueryParams(query, queryParams) {
    const newParams = [];
    const queryParsed = urijs_1.default.parseQuery(query || '');
    const disabledQueryParams = lodash_1.map(queryParams, (p, i) => (Object.assign(Object.assign({}, p), { index: i }))).filter(q => !q.isEnabled);
    for (const key of Object.keys(queryParsed)) {
        const existingQueryParam = queryParams.find(q => q.name === key);
        if (existingQueryParam) {
            newParams.push(Object.assign(Object.assign({}, existingQueryParam), { value: queryParsed[key], isEnabled: true }));
        }
        else {
            newParams.push({
                name: key,
                value: queryParsed[key],
                isEnabled: true,
            });
        }
    }
    for (const disabledQueryParam of disabledQueryParams) {
        if (!newParams.find(p => p.name === disabledQueryParam.name)) {
            newParams.splice(disabledQueryParam.index, 0, lodash_1.omit(disabledQueryParam, 'index'));
        }
    }
    if (query.endsWith('?') || query.endsWith('&')) {
        newParams.push({
            name: '',
            value: '',
            isEnabled: true,
        });
    }
    return newParams;
}
exports.extractQueryParams = extractQueryParams;
//# sourceMappingURL=url.js.map