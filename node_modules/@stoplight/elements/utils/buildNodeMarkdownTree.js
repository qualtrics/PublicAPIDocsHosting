"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const json_1 = require("@stoplight/json");
const markdown_viewer_1 = require("@stoplight/markdown-viewer");
const builder_1 = require("@stoplight/markdown/builder");
const types_1 = require("@stoplight/types");
function buildNodeMarkdownTree(type, data, errors) {
    var _a, _b;
    const markdown = new builder_1.Builder();
    if (type === types_1.NodeType.Article) {
        markdown.addMarkdown(String(data || ''));
    }
    else if (type === types_1.NodeType.Model) {
        const _c = (data || {}), { description } = _c, schema = tslib_1.__rest(_c, ["description"]);
        if (description) {
            markdown.addMarkdown(`${description}\n\n`);
        }
        const exampleTabs = [];
        if (schema['x-examples']) {
            for (const example in schema['x-examples']) {
                if (!schema['x-examples'][example])
                    continue;
                exampleTabs.push({
                    type: 'tab',
                    annotations: {
                        title: example,
                    },
                    children: [
                        {
                            type: 'code',
                            lang: 'json',
                            value: json_1.safeStringify(schema['x-examples'][example], undefined, 4),
                        },
                    ],
                });
            }
        }
        const schemaBlock = {
            type: 'code',
            lang: 'json',
            meta: 'model',
            value: json_1.safeStringify(schema, undefined, 4),
        };
        if ((_a = errors) === null || _a === void 0 ? void 0 : _a.length) {
            schemaBlock.annotations = { errors };
        }
        if (exampleTabs.length) {
            markdown.addChild({
                type: 'tabContainer',
                children: [
                    {
                        type: 'tab',
                        annotations: {
                            title: 'Schema',
                        },
                        children: [schemaBlock],
                    },
                    ...exampleTabs,
                ],
            });
        }
        else {
            markdown.addChild(schemaBlock);
        }
        markdown.addMarkdown('\n');
    }
    else {
        const codeBlock = {
            type: 'code',
            lang: 'json',
            meta: type,
            value: json_1.safeStringify(data, undefined, 4),
        };
        if ((_b = errors) === null || _b === void 0 ? void 0 : _b.length) {
            codeBlock.annotations = { errors };
        }
        markdown.addChild(codeBlock);
        markdown.addMarkdown('\n');
        if (type === types_1.NodeType.HttpOperation) {
            markdown.addMarkdown('\n');
        }
    }
    if (markdown.root.children.length === 0) {
        markdown.addMarkdown('No content');
    }
    return markdown_viewer_1.processMarkdownTree(markdown.root);
}
exports.buildNodeMarkdownTree = buildNodeMarkdownTree;
//# sourceMappingURL=buildNodeMarkdownTree.js.map