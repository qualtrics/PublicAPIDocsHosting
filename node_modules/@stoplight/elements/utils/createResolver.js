"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const path_1 = require("@stoplight/path");
const yaml_1 = require("@stoplight/yaml");
const urijs_1 = tslib_1.__importDefault(require("urijs"));
function createResolver(client, srn, resolverOpts) {
    return new json_ref_resolver_1.Resolver(Object.assign({ dereferenceInline: false, dereferenceRemote: false, resolvers: {
            https: httpResolver(client),
            http: httpResolver(client),
            file: remoteFileResolver(client, srn),
        }, parseResolveResult(opts) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (typeof opts.result === 'string') {
                    try {
                        opts.result = yaml_1.parse(opts.result);
                    }
                    catch (e) {
                    }
                }
                return opts;
            });
        } }, resolverOpts));
}
exports.createResolver = createResolver;
function remoteFileResolver(client, srn) {
    const { shortcode, orgSlug, projectSlug, uri } = path_1.deserializeSrn(srn || '');
    return {
        resolve(ref) {
            if (!uri) {
                throw new Error(`Failed to resolve ${ref}`);
            }
            const refSrn = path_1.serializeSrn({
                shortcode,
                orgSlug,
                projectSlug,
                uri: path_1.resolve(path_1.dirname(uri), String(ref)),
            });
            return httpResolver(client).resolve(new urijs_1.default(`/nodes.raw?srn=${refSrn}&deref=bundle`));
        },
    };
}
const httpResolver = (client = fetch) => {
    return {
        resolve: (ref) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const res = yield client(String(ref));
            return yield res.text();
        }),
    };
};
//# sourceMappingURL=createResolver.js.map