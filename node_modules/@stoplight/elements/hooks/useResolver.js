"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const React = tslib_1.__importStar(require("react"));
const Provider_1 = require("../containers/Provider");
const cancelablePromise_1 = require("../utils/cancelablePromise");
const createResolver_1 = require("../utils/createResolver");
const useFetchClient_1 = require("../utils/useFetchClient");
const useParsedData_1 = require("./useParsedData");
function useResolver(type, value) {
    const client = useFetchClient_1.useFetchClient();
    const srn = React.useContext(Provider_1.ActiveSrnContext);
    const resolverOpts = React.useContext(Provider_1.ResolverOptionsContext);
    const resolver = React.useContext(Provider_1.ResolverContext) || createResolver_1.createResolver(client, srn, resolverOpts);
    const parsedValue = useParsedData_1.useParsedData(type, value);
    const [resolved, setResolved] = React.useState({
        result: parsedValue,
        errors: [],
    });
    React.useEffect(() => {
        if (typeof parsedValue !== 'object')
            return;
        if (!resolverOpts) {
            setResolved({
                result: parsedValue,
                errors: [],
            });
            return;
        }
        const { promise, cancel } = cancelablePromise_1.cancelablePromise(resolver.resolve(parsedValue));
        promise
            .then(res => {
            setResolved({
                result: res.result,
                errors: lodash_1.uniqBy(res.errors, 'message'),
                graph: res.graph,
            });
        })
            .catch(e => {
            if (!e.isCanceled) {
                console.error('Error resolving', type, e);
            }
        });
        return () => {
            cancel();
        };
    }, [value, srn, parsedValue, resolverOpts]);
    return resolved;
}
exports.useResolver = useResolver;
//# sourceMappingURL=useResolver.js.map