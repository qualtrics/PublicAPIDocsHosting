"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = require("@stoplight/path");
const React = tslib_1.__importStar(require("react"));
const swr_1 = tslib_1.__importDefault(require("swr"));
const Provider_1 = require("../containers/Provider");
const useFetchClient_1 = require("../utils/useFetchClient");
function useProjectSearch(search, srn, opts = {}) {
    var _a;
    const projectSrn = path_1.serializeSrn(Object.assign(Object.assign({}, path_1.deserializeSrn(srn)), { uri: undefined }));
    const fetch = useFetchClient_1.useFetchClient();
    const projectToken = React.useContext(Provider_1.ProjectTokenContext);
    const queryParams = [`srn=${projectSrn}`, `first=${_a = opts.limit, (_a !== null && _a !== void 0 ? _a : 30)}`];
    if (search) {
        queryParams.push(`search=${search}`);
    }
    if (opts.group) {
        queryParams.push(`group=${opts.group}`);
    }
    if (projectToken) {
        queryParams.push(`token=${projectToken}`);
    }
    const { data, isValidating, error, revalidate } = swr_1.default(!opts.skip ? [`/projects.nodes?${queryParams.join('&')}`] : null, (input, init) => fetch(input, init).then(res => {
        if (!res.ok) {
            throw new Error(`${res.status} ${res.statusText}`);
        }
        return res.json();
    }), {
        shouldRetryOnError: false,
        revalidateOnFocus: false,
        dedupingInterval: 5 * 60 * 1000,
    });
    return {
        data,
        isValidating,
        error,
        revalidate,
    };
}
exports.useProjectSearch = useProjectSearch;
//# sourceMappingURL=useProjectSearch.js.map