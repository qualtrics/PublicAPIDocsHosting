"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("@stoplight/types");
const lodash_1 = require("lodash");
const React = tslib_1.__importStar(require("react"));
const Provider_1 = require("../containers/Provider");
const srns_1 = require("../utils/srns");
const README_REGEXP = new RegExp(`${lodash_1.escapeRegExp('README.md')}$`, 'i');
function useComputeToc(nodes) {
    const icons = React.useContext(Provider_1.IconsContext);
    return React.useMemo(() => computeToc(nodes, icons), [nodes, icons]);
}
exports.useComputeToc = useComputeToc;
function computeToc(_nodes, icons) {
    if (!_nodes.length)
        return [];
    const nodes = _nodes.map(n => (Object.assign(Object.assign({}, n), { uri: srns_1.deserializeSrn(n.srn).uri })));
    let contents = [];
    const folders = [];
    const rootNodes = [];
    const docsNodes = lodash_1.sortBy(nodes.filter(node => node.type === types_1.NodeType.Article), node => lodash_1.toLower(node.srn));
    for (const nodeIndex in docsNodes) {
        if (!docsNodes[nodeIndex])
            continue;
        const node = docsNodes[nodeIndex];
        const uri = node.uri.replace(/^\/(?:docs\/)?/, '');
        const parts = uri.split('/');
        if (parts.length > 1) {
            const pathToItem = parts.slice(0, -1);
            for (const pathIndex in pathToItem) {
                if (!pathToItem[pathIndex])
                    continue;
                const folderName = pathToItem[pathIndex];
                if (!folders.includes(`${folderName}/${pathIndex}`)) {
                    folders.push(`${folderName}/${pathIndex}`);
                    contents.push({
                        id: `${nodeIndex}-${pathIndex}`,
                        name: folderName
                            .split('-')
                            .map(item => lodash_1.upperFirst(item))
                            .join(' '),
                        depth: Number(pathIndex),
                        type: 'group',
                        icon: icons.group,
                    });
                }
            }
            contents.push({
                id: node.id,
                name: node.name,
                depth: parts.length - 1,
                type: 'item',
                icon: icons[node.type] || icons.item,
                href: node.srn,
            });
        }
        else {
            const contentNode = {
                id: node.id,
                name: node.name,
                depth: 0,
                type: 'item',
                icon: icons[node.type] || icons.item,
                href: node.srn,
            };
            if (README_REGEXP.test(node.uri)) {
                rootNodes.unshift(contentNode);
            }
            else {
                rootNodes.push(contentNode);
            }
        }
    }
    contents = rootNodes.concat(contents);
    const httpServiceNodes = lodash_1.sortBy(nodes.filter(n => n.type === types_1.NodeType.HttpService), node => lodash_1.toLower(node.name));
    for (const httpServiceNode of httpServiceNodes) {
        const parentUriRegexp = new RegExp(`^${lodash_1.escapeRegExp(httpServiceNode.uri)}\/`, 'i');
        const childNodes = nodes.filter(node => parentUriRegexp.test(node.uri) && node.type !== types_1.NodeType.HttpService);
        if (!childNodes.length)
            continue;
        const dividerNode = {
            id: httpServiceNode.id,
            name: httpServiceNode.name,
            depth: 0,
            type: 'divider',
            icon: icons[httpServiceNode.type] || icons.divider,
        };
        if (httpServiceNode.latestVersion && httpServiceNode.latestVersion !== '0.0') {
            dividerNode.meta = `v${httpServiceNode.latestVersion}`;
        }
        contents.push(dividerNode);
        contents.push({
            id: `${httpServiceNode.id}-overview`,
            name: 'Overview',
            depth: 0,
            icon: icons.item,
            type: 'item',
            href: httpServiceNode.srn,
        });
        const tags = {};
        const other = [];
        for (const childNode of childNodes) {
            if (childNode.tags && childNode.tags.length) {
                const tag = lodash_1.toLower(childNode.tags[0]);
                if (!tags[tag]) {
                    tags[tag] = [];
                }
                tags[tag].push(childNode);
            }
            else {
                other.push(childNode);
            }
        }
        const sortedTags = lodash_1.sortBy(Object.keys(tags), t => lodash_1.toLower(t));
        for (const tagIndex in sortedTags) {
            if (!sortedTags[tagIndex])
                continue;
            const tag = sortedTags[tagIndex];
            contents.push({
                id: `${httpServiceNode.id}-${tag}-${tagIndex}`,
                name: lodash_1.startCase(tag),
                depth: 0,
                type: 'group',
                icon: icons.group,
            });
            for (const tagChild of lodash_1.sortBy(tags[tag], 'name')) {
                contents.push({
                    id: tagChild.id,
                    name: tagChild.name,
                    depth: 1,
                    icon: icons[tagChild.type] || icons.item,
                    type: 'item',
                    href: tagChild.srn,
                });
            }
        }
        if (other.length) {
            contents.push({
                id: `${httpServiceNode.id}-other`,
                name: 'Other',
                depth: 0,
                type: 'group',
                icon: icons.group,
            });
            for (const otherChild of lodash_1.sortBy(other, n => lodash_1.toLower(n.name))) {
                contents.push({
                    id: otherChild.id,
                    name: otherChild.name,
                    depth: 1,
                    icon: icons[otherChild.type] || icons.item,
                    type: 'item',
                    href: otherChild.srn,
                });
            }
        }
    }
    const modelContents = [];
    const modelNodes = lodash_1.sortBy(nodes.filter(n => n.type === types_1.NodeType.Model), node => lodash_1.toLower(node.name));
    for (const modelNode of modelNodes) {
        if (contents.find(n => n.href === modelNode.srn))
            continue;
        const node = {
            id: modelNode.id,
            name: modelNode.name,
            href: modelNode.srn,
            depth: 0,
            type: 'item',
            icon: icons[modelNode.type] || icons.item,
        };
        if (modelNode.latestVersion && modelNode.latestVersion !== '0.0') {
            node.meta = `v${modelNode.latestVersion}`;
        }
        modelContents.push(node);
    }
    if (modelContents.length) {
        contents.push({
            id: 'models',
            name: 'Models',
            depth: 0,
            type: 'divider',
        });
        contents = contents.concat(modelContents);
    }
    return contents;
}
exports.computeToc = computeToc;
//# sourceMappingURL=useComputeToc.js.map