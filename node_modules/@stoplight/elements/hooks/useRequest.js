"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const json_1 = require("@stoplight/json");
const path_1 = require("@stoplight/path");
const lodash_1 = require("lodash");
const object_hash_1 = require("object-hash");
const React = tslib_1.__importStar(require("react"));
const __1 = require("..");
const useFetchClient_1 = require("../utils/useFetchClient");
const RequestCache = new Map();
function useRequest(args) {
    const requestContext = React.useContext(__1.RequestContext);
    const client = useFetchClient_1.useFetchClient();
    const computeUrl = React.useCallback(({ pathname, params }) => {
        const url = new URL(path_1.join(requestContext.host, path_1.stripRoot(pathname)));
        for (const [name, value] of Object.entries(params)) {
            if (value !== undefined) {
                url.searchParams.append(name, String(value));
            }
        }
        return url.href;
    }, [requestContext.host]);
    const [isLoading, setIsLoading] = React.useState(true);
    const [data, setData] = React.useState();
    const [error, setError] = React.useState();
    const { key, request } = useCreateRequest(args);
    React.useEffect(() => {
        const sendRequest = (req) => {
            let isMounted = true;
            const cachedData = RequestCache.get(key);
            if (cachedData) {
                setError(undefined);
                setData(cachedData);
                setIsLoading(false);
            }
            else {
                setIsLoading(true);
            }
            client(computeUrl(req))
                .then(response => response.json())
                .then(responseData => {
                if (!isMounted)
                    return;
                if (!cachedData || json_1.safeStringify(responseData) !== json_1.safeStringify(cachedData)) {
                    if (responseData.items && cachedData && cachedData.items) {
                        responseData.items.push(...cachedData.items);
                    }
                    RequestCache.set(key, responseData);
                    setData(responseData);
                }
                if (lodash_1.get(responseData, 'pageInfo.endCursor')) {
                    sendRequest(Object.assign(Object.assign({}, req), { params: Object.assign(Object.assign({}, req.params), { after: lodash_1.get(responseData, 'pageInfo.endCursor') }) }));
                }
                setError(undefined);
                setIsLoading(false);
            })
                .catch(e => {
                if (!isMounted)
                    return;
                if (!cachedData) {
                    RequestCache.delete(key);
                    setData(undefined);
                }
                setError(e);
                setIsLoading(false);
            });
            return () => {
                isMounted = false;
            };
        };
        return sendRequest(request);
    }, [request]);
    return {
        isLoading,
        data,
        error,
    };
}
exports.useRequest = useRequest;
function useCreateRequest(request) {
    const prev = React.useRef(null);
    return React.useMemo(() => {
        const key = object_hash_1.MD5(request);
        if (prev.current !== null && prev.current.key === key) {
            return prev.current;
        }
        else {
            prev.current = {
                key,
                request,
            };
            return prev.current;
        }
    }, [request]);
}
//# sourceMappingURL=useRequest.js.map