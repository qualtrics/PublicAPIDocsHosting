{"version":3,"file":"index.cjs.js","sources":["../src/types.ts","../src/errors.ts","../src/utils/guards.ts","../src/tree/metadata.ts","../src/utils/getCombiner.ts","../src/utils/inferType.ts","../src/utils/getPrimaryType.ts","../src/tree/utils/canStepIn.ts","../src/utils/generateId.ts","../src/tree/utils/createErrorTreeNode.ts","../src/tree/utils/mergeAllOf.ts","../src/utils/isValidType.ts","../src/utils/flattenTypes.ts","../src/utils/getAnnotations.ts","../src/utils/getValidations.ts","../src/utils/normalizeRequired.ts","../src/tree/utils/walk.ts","../src/tree/utils/populateTree.ts","../src/tree/tree.ts","../src/utils/isCombiner.ts","../src/utils/isSchemaViewerEmpty.ts","../src/components/shared/Caret.tsx","../src/components/shared/Description.tsx","../src/components/shared/Divider.tsx","../src/components/shared/Types.tsx","../src/components/shared/Property.tsx","../src/components/shared/Validations.tsx","../src/components/SchemaRow.tsx","../src/components/SchemaTree.tsx","../src/components/JsonSchemaViewer.tsx"],"sourcesContent":["import { IRowRendererOptions, TreeListNode, TreeStore } from '@stoplight/tree-list';\nimport { Dictionary } from '@stoplight/types';\nimport { JSONSchema4, JSONSchema4TypeName } from 'json-schema';\nimport * as React from 'react';\n\nexport enum SchemaKind {\n  Any = 'any',\n  String = 'string',\n  Number = 'number',\n  Integer = 'integer',\n  Boolean = 'boolean',\n  Null = 'null',\n  Array = 'array',\n  Object = 'object',\n}\n\nexport type JSONSchema4CombinerName = 'allOf' | 'anyOf' | 'oneOf';\n\nexport type JSONSchema4Annotations = 'title' | 'description' | 'default' | 'examples';\n\nexport type JSONSchema4Metadata = 'id' | '$schema';\n\nexport interface ICombinerNode {\n  id: string;\n  readonly combiner: JSONSchema4CombinerName;\n  properties?: JSONSchema4[];\n  annotations: Pick<JSONSchema4, JSONSchema4Annotations>;\n  readonly type?: JSONSchema4TypeName | JSONSchema4TypeName[];\n  title?: string;\n}\n\nexport interface IBaseNode extends Pick<JSONSchema4, 'enum'> {\n  id: string;\n  readonly type?: JSONSchema4TypeName | JSONSchema4TypeName[];\n  annotations: Partial<Pick<JSONSchema4, JSONSchema4Annotations>>;\n  validations: Dictionary<unknown>;\n  required?: string[];\n  title?: string;\n}\n\nexport interface IRefNode {\n  id: string;\n  $ref: string | null;\n  title?: string;\n}\n\nexport interface IArrayNode extends IBaseNode, Pick<JSONSchema4, 'items' | 'additionalItems'> {}\n\nexport interface IObjectNode\n  extends IBaseNode,\n    Pick<JSONSchema4, 'properties' | 'patternProperties' | 'additionalProperties'> {}\n\nexport interface IObjectPropertyNode extends IBaseNode {\n  name: string;\n}\n\nexport type SchemaNode = ICombinerNode | IBaseNode | IArrayNode | IObjectNode | IObjectPropertyNode | IRefNode;\n\nexport type SchemaTreeListNode = TreeListNode;\n\nexport type GoToRefHandler = (path: string, node: IRefNode) => void;\n\nexport type RowRenderer = (\n  node: TreeListNode,\n  rowOptions: IRowRendererOptions,\n  treeStore: TreeStore,\n) => React.ReactNode;\n","export class ResolvingError extends ReferenceError {\n  public readonly name = 'ResolvingError';\n}\n","import { JSONSchema4 } from 'json-schema';\nimport { isObjectLike as _isObjectLike } from 'lodash';\nimport { IArrayNode, ICombinerNode, IRefNode, SchemaKind, SchemaNode } from '../types';\n\nexport const isArrayNodeWithItems = (\n  node: SchemaNode,\n): node is Omit<IArrayNode, 'items'> & { items: JSONSchema4 | JSONSchema4[] } =>\n  'type' in node && 'items' in node && node.type === SchemaKind.Array && _isObjectLike(node.items);\n\nexport const isRefNode = (node: SchemaNode): node is IRefNode => '$ref' in node;\n\nexport const hasRefItems = (node: SchemaNode): node is Omit<IArrayNode, 'items'> & { items: Omit<IRefNode, 'id'> } =>\n  isArrayNodeWithItems(node) && '$ref' in node.items;\n\nexport const isCombinerNode = (node: SchemaNode): node is ICombinerNode => 'combiner' in node;\n","import { TreeListNode } from '@stoplight/tree-list';\nimport { JsonPath } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { SchemaNode, SchemaTreeListNode } from '../types';\n\nexport interface ITreeNodeMetaSchema {\n  path: JsonPath;\n  schemaNode: SchemaNode;\n  schema: JSONSchema4;\n}\n\nexport interface ITreeNodeMetaError {\n  path: JsonPath;\n  error: string;\n}\n\nexport type TreeNodeMeta = ITreeNodeMetaSchema | ITreeNodeMetaError;\n\nexport const metadataStore = new WeakMap<SchemaTreeListNode, TreeNodeMeta>();\n\nexport const getNodeMetadata = (node: TreeListNode): TreeNodeMeta => {\n  const metadata = metadataStore.get(node);\n  if (metadata === void 0) {\n    throw new Error('Missing metadata');\n  }\n\n  return metadata;\n};\n\nexport const getSchemaNodeMetadata = (node: TreeListNode): ITreeNodeMetaSchema => {\n  const metadata = getNodeMetadata(node);\n\n  if (!('schema' in metadata)) {\n    throw new TypeError('Schema node expected');\n  }\n\n  return metadata;\n};\n","import { JSONSchema4 } from 'json-schema';\nimport { JSONSchema4CombinerName } from '../types';\n\nexport const getCombiner = (node: JSONSchema4): JSONSchema4CombinerName | void => {\n  if ('allOf' in node) return 'allOf';\n  if ('anyOf' in node) return 'anyOf';\n  if ('oneOf' in node) return 'oneOf';\n};\n","import { Optional } from '@stoplight/types';\nimport { JSONSchema4, JSONSchema4TypeName } from 'json-schema';\nimport { SchemaKind, SchemaNode } from '../types';\n\nexport function inferType(node: SchemaNode | JSONSchema4): Optional<JSONSchema4TypeName | JSONSchema4TypeName[]> {\n  if ('type' in node) {\n    return node.type;\n  }\n\n  if ('properties' in node) {\n    return SchemaKind.Object;\n  }\n\n  if ('items' in node) {\n    return SchemaKind.Array;\n  }\n\n  return;\n}\n","import { JSONSchema4 } from 'json-schema';\nimport { SchemaKind, SchemaNode } from '../types';\nimport { inferType } from './inferType';\n\nexport function getPrimaryType(node: JSONSchema4 | SchemaNode) {\n  if ('type' in node && node.type !== undefined) {\n    if (Array.isArray(node.type)) {\n      if (node.type.includes(SchemaKind.Object)) {\n        return SchemaKind.Object;\n      }\n\n      if (node.type.includes(SchemaKind.Array)) {\n        return SchemaKind.Array;\n      }\n    }\n\n    return node.type;\n  }\n\n  return inferType(node);\n}\n","import { JSONSchema4 } from 'json-schema';\nimport { SchemaKind } from '../../types';\nimport { getCombiner } from '../../utils/getCombiner';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\n\nexport const canStepIn = (fragment: JSONSchema4) => {\n  if (getCombiner(fragment)) {\n    return true;\n  }\n\n  const type = getPrimaryType(fragment);\n  return type === SchemaKind.Array || type === SchemaKind.Object;\n};\n","export const generateId = (): string => Math.random().toString(36);\n","import { TreeListParentNode } from '@stoplight/tree-list';\nimport { SchemaTreeListNode } from '../../types';\nimport { generateId } from '../../utils/generateId';\nimport { getSchemaNodeMetadata, metadataStore } from '../metadata';\n\nexport function createErrorTreeNode(parent: TreeListParentNode, error: string) {\n  const { path } = getSchemaNodeMetadata(parent);\n\n  const errorNode: SchemaTreeListNode = {\n    id: generateId(),\n    name: '',\n    parent,\n  };\n\n  metadataStore.set(errorNode, {\n    path,\n    error,\n  });\n\n  return errorNode;\n}\n","import { pathToPointer, safeStringify } from '@stoplight/json';\nimport { JsonPath } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { ResolvingError } from '../../errors';\nimport { WalkingOptions } from './populateTree';\n\nconst resolveAllOf = require('@stoplight/json-schema-merge-allof');\n\nconst store = new WeakMap<WalkingOptions, WeakMap<JSONSchema4, string[]>>();\n\nfunction _mergeAllOf(schema: JSONSchema4, path: JsonPath, opts: WalkingOptions) {\n  return resolveAllOf(schema, {\n    deep: false,\n    resolvers: resolveAllOf.stoplightResolvers,\n    $refResolver($ref: unknown) {\n      if (typeof $ref !== 'string') {\n        return {};\n      }\n\n      if (pathToPointer(path).startsWith($ref)) {\n        throw new ResolvingError('Circular reference detected');\n      }\n\n      const allRefs = store.get(opts)!;\n      const schemaRefs = allRefs.get(schema);\n\n      if (schemaRefs === void 0) {\n        allRefs.set(schema, [$ref]);\n      } else if (schemaRefs.includes($ref)) {\n        const resolved = JSON.parse(safeStringify(opts.resolveRef(null, $ref)));\n        return 'allOf' in resolved ? _mergeAllOf(resolved, path, opts) : resolved;\n      } else {\n        schemaRefs.push($ref);\n      }\n\n      return opts.resolveRef(null, $ref);\n    },\n  });\n}\n\nexport const mergeAllOf = (schema: JSONSchema4, path: JsonPath, opts: WalkingOptions) => {\n  try {\n    if (!store.has(opts)) {\n      store.set(opts, new WeakMap());\n    }\n\n    return _mergeAllOf(schema, path, opts);\n  } catch (ex) {\n    console.error(ex.message);\n    throw ex;\n  }\n};\n","import { JSONSchema4TypeName } from 'json-schema';\nimport { SchemaKind } from '../types';\n\nexport const isValidType = (maybeType: unknown): maybeType is JSONSchema4TypeName =>\n  typeof maybeType === 'string' && Object.values(SchemaKind).includes(maybeType as SchemaKind);\n","import { Optional } from '@stoplight/types';\nimport { JSONSchema4TypeName } from 'json-schema';\nimport { isValidType } from './isValidType';\n\nfunction getTypeFromObject(obj: object): Optional<JSONSchema4TypeName> {\n  const size = Object.keys(obj).length;\n\n  if (size > 1 || !('type' in obj)) {\n    throw new Error(\n      'The \"type\" property must be a string, or an array of strings. Objects and array of objects are not valid.',\n    );\n  }\n\n  if ('type' in obj && isValidType((obj as { type: string }).type)) {\n    return (obj as { type: JSONSchema4TypeName }).type;\n  }\n\n  return;\n}\n\nfunction flattenType(type: unknown) {\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  if (typeof type !== 'object' || type === null) {\n    return;\n  }\n\n  return getTypeFromObject(type);\n}\n\nexport const flattenTypes = (types: unknown): Optional<JSONSchema4TypeName | JSONSchema4TypeName[]> => {\n  if (typeof types === 'string' && isValidType(types)) {\n    return types;\n  }\n\n  if (typeof types !== 'object' || types === null) {\n    return;\n  }\n\n  if (Array.isArray(types)) {\n    const flattenedTypes: JSONSchema4TypeName[] = [];\n    for (const type of types) {\n      const flattened = flattenType(type);\n      if (!isValidType(flattened) || flattenedTypes.includes(flattened)) continue;\n      flattenedTypes.push(flattened);\n    }\n\n    return flattenedTypes.length > 0 ? flattenedTypes : void 0;\n  }\n\n  return getTypeFromObject(types);\n};\n","import { JSONSchema4 } from 'json-schema';\nimport { pick as _pick } from 'lodash';\nimport { JSONSchema4Annotations } from '../types';\n\nconst ANNOTATIONS: JSONSchema4Annotations[] = ['description', 'default', 'examples'];\n\nexport function getAnnotations(node: JSONSchema4) {\n  return _pick(node, ANNOTATIONS);\n}\n","import { Dictionary, Optional } from '@stoplight/types';\nimport { JSONSchema4, JSONSchema4TypeName } from 'json-schema';\nimport { flatMap as _flatMap, pick as _pick } from 'lodash';\n\nexport const COMMON_VALIDATION_TYPES = [\n  'enum', // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1\n  'format', // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7\n  'default',\n  'example',\n  'nullable',\n  'discriminator',\n  'readOnly',\n  'writeOnly',\n  'xml',\n  'externalDocs',\n];\n\nconst VALIDATION_TYPES = {\n  string: ['minLength', 'maxLength', 'pattern'],\n  number: ['multipleOf', 'minimum', 'exclusiveMinimum', 'maximum', 'exclusiveMaximum'],\n  get integer() {\n    return this.number;\n  },\n  object: ['additionalProperties', 'minProperties', 'maxProperties'],\n  array: ['additionalItems', 'minItems', 'maxItems', 'uniqueItems'],\n};\n\nfunction getDeprecatedValue(node: JSONSchema4): Optional<boolean> {\n  if ('x-deprecated' in node) {\n    return !!node['x-deprecated'];\n  }\n\n  if ('deprecated' in node) {\n    return !!node.deprecated;\n  }\n\n  return;\n}\n\nfunction getTypeValidations(type: JSONSchema4TypeName | JSONSchema4TypeName[]): string[] {\n  if (Array.isArray(type)) {\n    return _flatMap(type, getTypeValidations);\n  }\n\n  return VALIDATION_TYPES[type] || [];\n}\n\nexport const getValidations = (node: JSONSchema4): Dictionary<unknown> => {\n  const extraValidations = node.type && getTypeValidations(node.type);\n  const deprecated = getDeprecatedValue(node);\n  return {\n    ..._pick(node, COMMON_VALIDATION_TYPES),\n    ...(extraValidations && _pick(node, extraValidations)),\n    ...(deprecated !== void 0 && { deprecated }),\n  };\n};\n","import { Optional } from '@stoplight/types';\n\nexport const normalizeRequired = (required: unknown): Optional<string[]> => {\n  if (!Array.isArray(required)) return;\n  return required.filter(item => typeof item === 'string' || typeof item === 'number').map(String);\n};\n","import { Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { isObject as _isObject } from 'lodash';\nimport { IArrayNode, IBaseNode, ICombinerNode, IObjectNode, SchemaKind, SchemaNode } from '../../types';\nimport { flattenTypes } from '../../utils/flattenTypes';\nimport { generateId } from '../../utils/generateId';\nimport { getAnnotations } from '../../utils/getAnnotations';\nimport { getCombiner } from '../../utils/getCombiner';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\nimport { getValidations } from '../../utils/getValidations';\nimport { inferType } from '../../utils/inferType';\nimport { normalizeRequired } from '../../utils/normalizeRequired';\n\nfunction assignNodeSpecificFields(base: IBaseNode, node: JSONSchema4) {\n  switch (getPrimaryType(node)) {\n    case SchemaKind.Array:\n      (base as IArrayNode).items = unwrapItemsOrUndefined(node.items);\n      (base as IArrayNode).additionalItems =\n        typeof node.additionalItems === 'boolean' ? node.additionalItems : unwrapItemsOrUndefined(node.additionalItems);\n      break;\n    case SchemaKind.Object:\n      (base as IObjectNode).properties = unwrapPropertiesOrUndefined(node.properties);\n      (base as IObjectNode).patternProperties = unwrapPropertiesOrUndefined(node.patternProperties);\n      (base as IObjectNode).additionalProperties =\n        typeof node.additionalProperties === 'boolean'\n          ? node.additionalProperties\n          : unwrapPropertiesOrUndefined(node.additionalProperties);\n      break;\n  }\n}\n\nfunction processNode(node: JSONSchema4): SchemaNode | void {\n  const combiner = getCombiner(node);\n  const type = node.type || inferType(node);\n  const title = typeof node.title === 'string' ? { title: node.title } : null;\n\n  if (combiner) {\n    const properties = node[combiner];\n    return {\n      id: generateId(),\n      combiner,\n      properties: Array.isArray(properties) ? properties.slice() : properties,\n      annotations: getAnnotations(node),\n      ...(type !== undefined && { type }),\n      ...title,\n    } as ICombinerNode;\n  }\n\n  if (type) {\n    const base: IBaseNode = {\n      id: generateId(),\n      type: flattenTypes(type),\n      validations: getValidations(node),\n      annotations: getAnnotations(node),\n      ...('required' in node && { required: normalizeRequired(node.required) }),\n      enum: node.enum,\n      ...title,\n    };\n\n    assignNodeSpecificFields(base, node);\n\n    return base;\n  }\n\n  if ('enum' in node) {\n    return {\n      id: generateId(),\n      validations: getValidations(node),\n      annotations: getAnnotations(node),\n      enum: node.enum,\n      ...title,\n    };\n  }\n\n  if ('$ref' in node) {\n    return {\n      id: generateId(),\n      $ref: typeof node.$ref !== 'string' ? null : node.$ref,\n      ...title,\n    };\n  }\n\n  // if ('not' in node) {\n  //   // todo: shall we support it?\n  // }\n\n  return {\n    id: generateId(),\n    validations: {},\n    annotations: {},\n  };\n}\n\nexport type WalkerValue = {\n  node: SchemaNode;\n  fragment: JSONSchema4;\n};\n\nexport function* walk(schema: JSONSchema4[] | JSONSchema4): IterableIterator<WalkerValue> {\n  if (Array.isArray(schema)) {\n    for (const segment of schema) {\n      yield* walk(segment);\n    }\n  } else {\n    const node = processNode(schema);\n    if (node !== void 0) {\n      yield {\n        node,\n        fragment: schema,\n      };\n    }\n  }\n}\n\nfunction unwrapItemsOrUndefined<T = unknown>(value: T): Optional<T> {\n  return _isObject(value) ? value : void 0;\n}\n\nfunction unwrapPropertiesOrUndefined<T = unknown>(value: T): Optional<T> {\n  return _isObject(value) && !Array.isArray(value) ? value : void 0;\n}\n","import { TreeListNode, TreeListParentNode } from '@stoplight/tree-list';\nimport { JsonPath, Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { isObject as _isObject } from 'lodash';\nimport { IArrayNode, IObjectNode, SchemaKind, SchemaNode, SchemaTreeListNode } from '../../types';\nimport { getCombiner } from '../../utils/getCombiner';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\nimport { isCombinerNode, isRefNode } from '../../utils/guards';\nimport { getNodeMetadata, getSchemaNodeMetadata, metadataStore } from '../metadata';\nimport { createErrorTreeNode } from './createErrorTreeNode';\nimport { mergeAllOf } from './mergeAllOf';\nimport { walk } from './walk';\n\nexport type WalkerRefResolver = (path: JsonPath | null, $ref: string) => JSONSchema4;\n\nexport type WalkingOptions = {\n  mergeAllOf: boolean;\n  onNode?(fragment: JSONSchema4, node: SchemaNode, parentTreeNode: TreeListNode, level: number): boolean | void;\n  stepIn?: boolean;\n  resolveRef: WalkerRefResolver;\n  shouldResolveEagerly: boolean;\n};\n\nexport type Walker = (\n  schema: Optional<JSONSchema4 | null>,\n  parent: TreeListParentNode,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n) => undefined;\n\nexport const populateTree: Walker = (schema, parent, level, path, options): undefined => {\n  const actualSchema = prepareSchema(schema, parent, path, options);\n\n  if (!_isObject(actualSchema)) return;\n\n  for (const { node, fragment } of walk(actualSchema)) {\n    if (options !== null && options.onNode !== void 0 && !options.onNode(fragment, node, parent, level)) continue;\n\n    const treeNode: SchemaTreeListNode = {\n      id: node.id,\n      name: '',\n      parent,\n    };\n\n    parent.children.push(treeNode);\n    metadataStore.set(treeNode, {\n      schemaNode: node,\n      schema: fragment,\n      path,\n    });\n\n    if (isRefNode(node) && node.$ref !== null) {\n      processRef(treeNode, node as JSONSchema4, level, path, options);\n    } else if (!isCombinerNode(node)) {\n      switch (getPrimaryType(node)) {\n        case SchemaKind.Array:\n          processArray(treeNode, node as IArrayNode, level, path, options);\n          break;\n        case SchemaKind.Object:\n          processObject(treeNode, node as IObjectNode, level, path, options);\n          break;\n      }\n    } else if (node.combiner === 'allOf' && options?.mergeAllOf) {\n      try {\n        const merged = mergeAllOf(fragment, path, options);\n        parent.children.pop();\n        populateTree(merged, parent, level, path, options);\n      } catch (ex) {\n        if (Array.isArray(fragment.allOf)) {\n          (treeNode as TreeListParentNode).children = [];\n          bailAllOf(treeNode as TreeListParentNode, fragment, level + 1, [...path, 'allOf'], options);\n        }\n      }\n    } else if (_isObject(node.properties)) {\n      (treeNode as TreeListParentNode).children = [];\n\n      for (const [i, property] of node.properties.entries()) {\n        if ('type' in node) {\n          node.properties[i] = {\n            ...property,\n            type: property.type || node.type,\n          };\n        }\n\n        populateTree(\n          node.properties[i],\n          treeNode as TreeListParentNode,\n          level + 1,\n          [...path, node.combiner, i],\n          options,\n        );\n      }\n    }\n  }\n\n  return;\n};\n\nfunction processArray(\n  node: SchemaTreeListNode,\n  schema: IArrayNode,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n): SchemaTreeListNode {\n  const items = prepareSchema(schema.items, node, path, options);\n\n  if (!_isObject(items)) return node;\n\n  if (items !== schema.items) {\n    // we need to update the stored metadata to make sure the subtype of given array correctly inferred by Property component\n    const metadata = getNodeMetadata(node);\n    if ('schemaNode' in metadata) {\n      (metadata.schemaNode as IArrayNode).items = items;\n    }\n  }\n\n  if ('$ref' in items) {\n    processRef(node, items, level, path, options);\n  } else if (Array.isArray(items)) {\n    const children: SchemaTreeListNode[] = [];\n    (node as TreeListParentNode).children = children;\n    for (const [i, property] of items.entries()) {\n      const child = populateTree(property, node as TreeListParentNode, level + 1, [...path, 'items', i], options);\n      if (child !== void 0) {\n        children.push(child);\n      }\n    }\n  } else {\n    const subtype = getPrimaryType(items);\n    switch (subtype) {\n      case SchemaKind.Object:\n        return processObject(node, items as IObjectNode, level, [...path, 'items'], options);\n      case SchemaKind.Array:\n        return processArray(node, items as IObjectNode, level, [...path, 'items'], options);\n      default:\n        const combiner = getCombiner(items);\n        if (combiner) {\n          (node as TreeListParentNode).children = [];\n          populateTree(items, node as TreeListParentNode, level, [...path, 'items'], options);\n        }\n    }\n  }\n\n  return node;\n}\n\nfunction processObject(\n  node: TreeListNode,\n  schema: IObjectNode,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n): TreeListNode {\n  const children: TreeListNode[] = [];\n\n  if (_isObject(schema.properties)) {\n    (node as TreeListParentNode).children = children;\n\n    for (const [prop, property] of Object.entries(schema.properties)) {\n      const child = populateTree(\n        property,\n        node as TreeListParentNode,\n        level + 1,\n        [...path, 'properties', prop],\n        options,\n      );\n      if (child !== void 0) {\n        children.push(child);\n      }\n    }\n  }\n\n  if (_isObject(schema.patternProperties)) {\n    (node as TreeListParentNode).children = children;\n\n    for (const [prop, property] of Object.entries(schema.patternProperties)) {\n      const child = populateTree(\n        property,\n        node as TreeListParentNode,\n        level + 1,\n        [...path, 'patternProperties', prop],\n        options,\n      );\n      if (child !== void 0) {\n        children.push(child);\n      }\n    }\n  }\n\n  return node;\n}\n\nfunction processRef(\n  node: TreeListNode,\n  schema: JSONSchema4,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n) {\n  (node as TreeListParentNode).children = [];\n  try {\n    const resolved = resolveSchema(schema, path, options);\n    if (_isObject(resolved) && typeof resolved.title === 'string') {\n      const { schemaNode } = getSchemaNodeMetadata(node);\n      schemaNode.title = resolved.title;\n    }\n  } catch {\n    // resolving failed, nothing bad. We just won't have the title\n  }\n}\n\nfunction bailAllOf(\n  node: TreeListParentNode,\n  schema: JSONSchema4,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n) {\n  if (Array.isArray(schema.allOf)) {\n    for (const [i, item] of schema.allOf.entries()) {\n      populateTree(item, node, level, [...path, i], options);\n    }\n  }\n}\n\nfunction resolveSchema(schema: Optional<JSONSchema4 | null>, path: JsonPath, options: WalkingOptions | null) {\n  if (!_isObject(schema) || options === null || !('$ref' in schema) || typeof schema.$ref !== 'string') {\n    return schema;\n  }\n\n  const resolved = options.resolveRef(path, schema.$ref);\n  return _isObject(resolved) ? resolved : schema;\n}\n\nfunction prepareSchema(\n  schema: Optional<JSONSchema4 | null>,\n  node: TreeListNode,\n  path: JsonPath,\n  options: WalkingOptions | null,\n): Optional<JSONSchema4 | null> {\n  if (options === null || !options.shouldResolveEagerly) return schema;\n\n  try {\n    return resolveSchema(schema, path, options);\n  } catch (ex) {\n    (node as TreeListParentNode).children = [];\n    return void (node as TreeListParentNode).children.push(createErrorTreeNode(node as TreeListParentNode, ex.message));\n  }\n}\n","import { extractPointerFromRef, extractSourceFromRef, pointerToPath } from '@stoplight/json';\nimport { Tree, TreeListParentNode, TreeState } from '@stoplight/tree-list';\nimport { JsonPath, Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { get as _get, isEqual as _isEqual, isObject as _isObject } from 'lodash';\nimport { ResolvingError } from '../errors';\nimport { hasRefItems, isRefNode } from '../utils/guards';\nimport { getSchemaNodeMetadata } from './metadata';\nimport { canStepIn } from './utils/canStepIn';\nimport { createErrorTreeNode } from './utils/createErrorTreeNode';\nimport { populateTree, WalkerRefResolver } from './utils/populateTree';\n\nexport type SchemaTreeRefInfo = {\n  source: string | null;\n  pointer: string | null;\n};\n\nexport type SchemaTreeRefDereferenceFn = (\n  ref: SchemaTreeRefInfo,\n  propertyPath: JsonPath | null,\n  schema: JSONSchema4,\n) => Optional<JSONSchema4>;\n\nexport type SchemaTreePopulateHandler = (tree: SchemaTree, node: TreeListParentNode) => void;\n\nexport type SchemaTreeOptions = {\n  expandedDepth: number;\n  mergeAllOf: boolean;\n  resolveRef: Optional<SchemaTreeRefDereferenceFn>;\n  shouldResolveEagerly: boolean;\n  onPopulate: Optional<SchemaTreePopulateHandler>;\n};\n\nexport { TreeState as SchemaTreeState };\n\nexport class SchemaTree extends Tree {\n  public treeOptions: SchemaTreeOptions;\n\n  constructor(public schema: JSONSchema4, public state: TreeState, opts: SchemaTreeOptions) {\n    super({\n      expanded: node =>\n        (!(node.id in state.expanded) && SchemaTree.getLevel(node) <= opts.expandedDepth) ||\n        state.expanded[node.id] === true,\n    });\n\n    this.treeOptions = opts;\n  }\n\n  protected readonly visited = new WeakSet();\n\n  public populate() {\n    const expanded = {};\n    populateTree(this.schema, this.root, 0, [], {\n      mergeAllOf: this.treeOptions.mergeAllOf,\n      onNode: (fragment, node, parentTreeNode, level): boolean => {\n        if (\n          !this.treeOptions.shouldResolveEagerly &&\n          ((isRefNode(node) && node.$ref !== null) || (hasRefItems(node) && node.items.$ref !== null))\n        ) {\n          expanded[node.id] = false;\n        }\n\n        const metadata = Tree.getLevel(parentTreeNode) >= 0 ? getSchemaNodeMetadata(parentTreeNode) : void 0;\n\n        if (metadata !== void 0 && isRefNode(metadata.schemaNode)) return false;\n        return level <= this.treeOptions.expandedDepth + 1;\n      },\n      resolveRef: this.resolveRef,\n      shouldResolveEagerly: this.treeOptions.shouldResolveEagerly,\n    });\n    this.state.expanded = expanded;\n    this.invalidate();\n    this.treeOptions.onPopulate?.(this, this.root);\n  }\n\n  public populateTreeFragment(parent: TreeListParentNode, schema: JSONSchema4, path: JsonPath, stepIn: boolean) {\n    const initialLevel = Tree.getLevel(parent);\n    const artificialRoot = Tree.createArtificialRoot();\n    populateTree(schema, artificialRoot, initialLevel, path, {\n      mergeAllOf: this.treeOptions.mergeAllOf,\n      onNode: (fragment, node, parentTreeNode, level) => {\n        if (level <= this.treeOptions.expandedDepth || level <= initialLevel) return true;\n        return stepIn && level <= initialLevel + 1 && canStepIn(getSchemaNodeMetadata(parentTreeNode).schema);\n      },\n      resolveRef: this.resolveRef,\n      shouldResolveEagerly: this.treeOptions.shouldResolveEagerly,\n    });\n\n    if (artificialRoot.children.length === 0) {\n      throw new Error(`Could not expand node ${path.join('.')}`);\n    }\n\n    this.insertTreeFragment(stepIn ? this.stepIn(artificialRoot, parent) : artificialRoot.children, parent);\n\n    this.treeOptions.onPopulate?.(this, parent);\n  }\n\n  protected insertErrorNode(parent: TreeListParentNode, error: string) {\n    this.insertNode(createErrorTreeNode(parent, error), parent);\n  }\n\n  protected stepIn(root: TreeListParentNode, parent: TreeListParentNode) {\n    if (\n      root.children.length > 0 &&\n      'children' in root.children[0] &&\n      _isEqual(getSchemaNodeMetadata(parent).path, getSchemaNodeMetadata(root.children[0]).path)\n    ) {\n      return root.children[0].children;\n    }\n\n    return root.children;\n  }\n\n  public unwrap(node: TreeListParentNode) {\n    if (node.children.length !== 0 || this.visited.has(node)) {\n      return super.unwrap(node);\n    }\n    const metadata = getSchemaNodeMetadata(node);\n    const { path, schemaNode, schema } = metadata;\n    try {\n      if (!isRefNode(schemaNode) && !hasRefItems(schemaNode)) {\n        this.populateTreeFragment(node, schema, path, true);\n      } else if (isRefNode(schemaNode)) {\n        this.populateRefFragment(node, path, schemaNode.$ref);\n      } else if (hasRefItems(schemaNode)) {\n        this.populateRefFragment(node, [...path, 'items'], schemaNode.items.$ref);\n      } else {\n        throw new Error(`I do know not how to expand this node ${path.join('.')}`);\n      }\n    } catch (ex) {\n      this.insertErrorNode(node, ex.message);\n    }\n\n    this.visited.add(node);\n    return super.unwrap(node);\n  }\n\n  protected resolveRef: WalkerRefResolver = (path, $ref) => {\n    const source = extractSourceFromRef($ref);\n    const pointer = extractPointerFromRef($ref);\n\n    if (this.treeOptions.resolveRef !== void 0) {\n      return this.treeOptions.resolveRef({ source, pointer }, path, this.schema);\n    } else if (source !== null) {\n      throw new ResolvingError('Cannot dereference external references');\n    } else if (pointer === null) {\n      throw new ResolvingError('The pointer is empty');\n    } else {\n      return _get(this.schema, pointerToPath(pointer));\n    }\n  };\n\n  protected populateRefFragment(node: TreeListParentNode, path: JsonPath, $ref: string | null) {\n    if ($ref === null) {\n      throw new Error('Unknown $ref value');\n    }\n\n    const schemaFragment = this.resolveRef(path, $ref);\n\n    if (!_isObject(schemaFragment)) {\n      throw new ResolvingError(`Could not dereference \"${$ref}\"`);\n    }\n\n    this.populateTreeFragment(node, schemaFragment, path, false);\n  }\n}\n","import { JSONSchema4CombinerName } from '../types';\n\nconst combinerTypes = ['allOf', 'oneOf', 'anyOf'];\n\nexport const isCombiner = (type: string): type is JSONSchema4CombinerName => combinerTypes.includes(type);\n","import { get as _get, isEmpty as _isEmpty } from 'lodash';\nimport { isCombiner } from './isCombiner';\n\nexport const isSchemaViewerEmpty = (schema: unknown) => {\n  if (typeof schema !== 'object' || schema === null) return true;\n\n  const objectKeys = Object.keys(schema);\n  if (objectKeys.length === 1 && isCombiner(objectKeys[0])) {\n    return _isEmpty(_get(schema, objectKeys[0], []));\n  }\n\n  return false;\n};\n","import { Icon, IIconProps } from '@stoplight/ui-kit';\nimport * as React from 'react';\n\nexport interface ICaret {\n  isExpanded: boolean;\n  style?: React.CSSProperties;\n  size?: IIconProps['iconSize'];\n}\n\nexport const Caret: React.FunctionComponent<ICaret> = ({ style, size, isExpanded }) => (\n  <span\n    className=\"absolute flex justify-center cursor-pointer p-1 rounded hover:bg-darken-3\"\n    role=\"button\"\n    style={style}\n  >\n    <Icon\n      iconSize={size}\n      icon={isExpanded ? 'caret-down' : 'caret-right'}\n      className=\"text-darken-9 dark:text-lighten-7\"\n    />\n  </span>\n);\n","import { MarkdownViewer } from '@stoplight/markdown-viewer';\nimport { Popover } from '@stoplight/ui-kit';\nimport * as React from 'react';\n\nexport const Description: React.FunctionComponent<{ value: string }> = ({ value }) => (\n  <Popover\n    boundary=\"window\"\n    interactionKind=\"hover\"\n    className=\"ml-2 flex-1 truncate flex items-baseline\"\n    target={<div className=\"text-darken-7 dark:text-lighten-7 w-full truncate\">{value}</div>}\n    targetClassName=\"text-darken-7 dark:text-lighten-6 w-full truncate\"\n    content={\n      <div className=\"p-5\" style={{ maxHeight: 500, maxWidth: 400 }}>\n        <MarkdownViewer markdown={value} />\n      </div>\n    }\n  />\n);\n","import { Dictionary } from '@stoplight/types';\nimport * as React from 'react';\nimport { JSONSchema4CombinerName } from '../../types';\n\nconst DIVIDERS: Dictionary<string, JSONSchema4CombinerName> = {\n  allOf: 'and',\n  anyOf: 'and/or',\n  oneOf: 'or',\n};\n\nexport const Divider: React.FunctionComponent<{ kind: JSONSchema4CombinerName }> = ({ kind }) => (\n  <div className=\"flex items-center w-full absolute\" style={{ top: -9, height: 1 }}>\n    <div className=\"text-darken-7 dark:text-lighten-8 uppercase text-xs pr-2 -ml-4\">{DIVIDERS[kind]}</div>\n    <div className=\"flex-1 bg-darken-5 dark:bg-lighten-5\" style={{ height: 1 }} />\n  </div>\n);\n","import { Dictionary, Optional } from '@stoplight/types';\nimport cn from 'classnames';\nimport { JSONSchema4TypeName } from 'json-schema';\nimport * as React from 'react';\n\nimport { JSONSchema4CombinerName, SchemaKind } from '../../types';\n\n/**\n * TYPE\n */\nexport interface IType {\n  type: JSONSchema4TypeName | JSONSchema4CombinerName | 'binary' | '$ref';\n  subtype: Optional<JSONSchema4TypeName | JSONSchema4TypeName[]> | '$ref';\n  className?: string;\n  title: Optional<string>;\n}\n\nfunction shouldRenderTitle(type: string): boolean {\n  return type === SchemaKind.Array || type === SchemaKind.Object || type === '$ref';\n}\n\nfunction getPrintableArrayType(subtype: IType['subtype'], title: IType['title']): string {\n  if (!subtype) return SchemaKind.Array;\n\n  if (Array.isArray(subtype)) {\n    return `${SchemaKind.Array}[${subtype.join(',')}]`;\n  }\n\n  if (title && shouldRenderTitle(subtype)) {\n    return `${title}[]`;\n  }\n\n  if (subtype !== SchemaKind.Array && subtype !== '$ref') {\n    return `${SchemaKind.Array}[${subtype}]`;\n  }\n\n  return SchemaKind.Array;\n}\n\nfunction getPrintableType(type: IType['type'], subtype: IType['subtype'], title: IType['title']): string {\n  if (type === SchemaKind.Array) {\n    return getPrintableArrayType(subtype, title);\n  } else if (title && shouldRenderTitle(type)) {\n    return title;\n  } else {\n    return type;\n  }\n}\n\nexport const Type: React.FunctionComponent<IType> = ({ className, title, type, subtype }) => {\n  return (\n    <span className={cn(className, PropertyTypeColors[type], 'truncate')}>\n      {getPrintableType(type, subtype, title)}\n    </span>\n  );\n};\nType.displayName = 'JsonSchemaViewer.Type';\n\n/**\n * TYPES\n */\ninterface ITypes {\n  className?: string;\n  type: Optional<JSONSchema4TypeName | JSONSchema4TypeName[] | JSONSchema4CombinerName | '$ref'>;\n  subtype: Optional<JSONSchema4TypeName | JSONSchema4TypeName[] | '$ref'>;\n  title: Optional<string>;\n}\n\nexport const Types: React.FunctionComponent<ITypes> = ({ className, title, type, subtype }) => {\n  if (type === void 0) return null;\n\n  if (!Array.isArray(type)) {\n    return <Type className={className} type={type} subtype={subtype} title={title} />;\n  }\n\n  return (\n    <div className={cn(className, 'truncate')}>\n      <>\n        {type.map((name, i, { length }) => (\n          <React.Fragment key={i}>\n            <Type key={i} type={name} subtype={subtype} title={title} />\n\n            {i < length - 1 && (\n              <span key={`${i}-sep`} className=\"text-darken-7 dark:text-lighten-6\">\n                {' or '}\n              </span>\n            )}\n          </React.Fragment>\n        ))}\n      </>\n    </div>\n  );\n};\nTypes.displayName = 'JsonSchemaViewer.Types';\n\n/**\n * HELPERS\n */\nexport const PropertyTypeColors: Dictionary<string, IType['type']> = {\n  object: 'text-blue-6 dark:text-blue-4',\n  any: 'text-blue-5',\n  array: 'text-green-6 dark:text-green-4',\n  allOf: 'text-orange-5',\n  anyOf: 'text-orange-5',\n  oneOf: 'text-orange-5',\n  null: 'text-orange-5',\n  integer: 'text-red-7 dark:text-red-6',\n  number: 'text-red-7 dark:text-red-6',\n  boolean: 'text-red-4',\n  binary: 'text-green-4',\n  string: 'text-green-7 dark:text-green-5',\n  $ref: 'text-purple-6 dark:text-purple-4',\n};\n","import { isLocalRef } from '@stoplight/json';\nimport { Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { isObject as _isObject, size as _size } from 'lodash';\nimport * as React from 'react';\nimport { getSchemaNodeMetadata } from '../../tree/metadata';\nimport { GoToRefHandler, IArrayNode, IObjectNode, SchemaKind, SchemaNode, SchemaTreeListNode } from '../../types';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\nimport { hasRefItems, isArrayNodeWithItems, isCombinerNode, isRefNode } from '../../utils/guards';\nimport { inferType } from '../../utils/inferType';\nimport { Types } from './Types';\n\nexport interface IProperty {\n  node: SchemaTreeListNode;\n  onGoToRef?: GoToRefHandler;\n}\n\nfunction count(obj: Optional<JSONSchema4 | null>): number | null {\n  if (_isObject(obj)) {\n    return _size(obj);\n  }\n\n  return null;\n}\n\nfunction shouldShowPropertyName(treeNode: SchemaTreeListNode) {\n  if (treeNode.parent === null) return false;\n  try {\n    const { schemaNode } = getSchemaNodeMetadata(treeNode.parent);\n    if (!('type' in schemaNode)) {\n      return false;\n    }\n\n    let type = getPrimaryType(schemaNode);\n\n    if (type === SchemaKind.Array && (schemaNode as IArrayNode).items) {\n      type = getPrimaryType((schemaNode as IArrayNode).items!);\n    }\n\n    return type === SchemaKind.Object;\n  } catch {\n    return false;\n  }\n}\n\nfunction isExternalRefSchemaNode(schemaNode: SchemaNode) {\n  return isRefNode(schemaNode) && schemaNode.$ref !== null && !isLocalRef(schemaNode.$ref);\n}\n\nfunction retrieve$ref(node: SchemaNode): Optional<string> {\n  if (isRefNode(node) && node.$ref !== null) {\n    return node.$ref;\n  }\n\n  if (hasRefItems(node) && node.items.$ref !== null) {\n    return `$ref(${node.items.$ref})`;\n  }\n\n  return;\n}\n\nfunction getTitle(node: SchemaNode): Optional<string> {\n  if (isArrayNodeWithItems(node)) {\n    if (Array.isArray(node.items) || !node.items.title) {\n      return retrieve$ref(node);\n    }\n\n    return node.items.title;\n  }\n\n  return node.title || retrieve$ref(node);\n}\n\nexport const Property: React.FunctionComponent<IProperty> = ({ node: treeNode, onGoToRef }) => {\n  const { path, schemaNode: node } = getSchemaNodeMetadata(treeNode);\n  const type = isRefNode(node) ? '$ref' : isCombinerNode(node) ? node.combiner : node.type;\n  const subtype = isArrayNodeWithItems(node) ? (hasRefItems(node) ? '$ref' : inferType(node.items)) : void 0;\n  const title = getTitle(node);\n\n  const childrenCount = React.useMemo<number | null>(() => {\n    if (type === SchemaKind.Object || (Array.isArray(type) && type.includes(SchemaKind.Object))) {\n      return count((node as IObjectNode).properties);\n    }\n\n    if (subtype === SchemaKind.Object) {\n      return count(((node as IArrayNode).items as IObjectNode).properties);\n    }\n\n    if (subtype === SchemaKind.Array) {\n      return count((node as IArrayNode).items as IArrayNode);\n    }\n\n    return null;\n  }, [node]);\n\n  const handleGoToRef = React.useCallback<React.MouseEventHandler>(() => {\n    if (onGoToRef && isRefNode(node) && node.$ref !== null) {\n      onGoToRef(node.$ref, node);\n    }\n  }, [onGoToRef, node]);\n\n  return (\n    <>\n      {path.length > 0 && shouldShowPropertyName(treeNode) && <div className=\"mr-2\">{path[path.length - 1]}</div>}\n\n      <Types type={type} subtype={subtype} title={title} />\n\n      {onGoToRef && isExternalRefSchemaNode(node) ? (\n        <a role=\"button\" className=\"text-blue-4 ml-2\" onClick={handleGoToRef}>\n          (go to ref)\n        </a>\n      ) : null}\n\n      {childrenCount !== null && <div className=\"ml-2 text-darken-7 dark:text-lighten-7\">{`{${childrenCount}}`}</div>}\n\n      {path.length > 1 && path[path.length - 2] === 'patternProperties' ? (\n        <div className=\"ml-2 text-darken-7 dark:text-lighten-7 truncate\">(pattern property)</div>\n      ) : null}\n    </>\n  );\n};\n","import { safeStringify } from '@stoplight/json';\nimport { Dictionary } from '@stoplight/types';\nimport { Popover } from '@stoplight/ui-kit';\nimport cn from 'classnames';\nimport * as React from 'react';\n\nexport interface IValidations {\n  required: boolean;\n  validations: (Dictionary<unknown> | {}) & { deprecated?: boolean };\n}\n\nexport const Validations: React.FunctionComponent<IValidations> = ({\n  required,\n  validations: { deprecated, ...validations },\n}) => {\n  const validationCount = Object.keys(validations).length;\n\n  const requiredElem = (\n    <div className={cn('ml-2', required ? 'font-medium' : 'text-darken-7 dark:text-lighten-6')}>\n      {required ? 'required' : 'optional'}\n      {validationCount ? `+${validationCount}` : ''}\n    </div>\n  );\n\n  return (\n    <>\n      {deprecated ? <span className=\"ml-2 text-orange-7 dark:text-orange-6\">deprecated</span> : null}\n      {validationCount ? (\n        <Popover\n          boundary=\"window\"\n          interactionKind=\"hover\"\n          content={\n            <div className=\"p-5\" style={{ maxHeight: 500, maxWidth: 400 }}>\n              {Object.keys(validations).map((key, index) => {\n                const validation = validations[key];\n\n                let elem = null;\n                if (Array.isArray(validation)) {\n                  elem = validation.map((v, i) => (\n                    <div key={i} className=\"mt-1 mr-1 flex items-center\">\n                      <div className=\"px-1 bg-gray-2 dark:bg-gray-8 font-bold text-sm rounded\">{String(v)}</div>\n                      {i < validation.length - 1 ? <div>,</div> : null}\n                    </div>\n                  ));\n                } else if (typeof validation === 'object') {\n                  elem = (\n                    <div className=\"m-1 px-1 bg-gray-2 dark:bg-gray-8 font-bold text-sm rounded\" key={index}>\n                      {'{...}'}\n                    </div>\n                  );\n                } else {\n                  elem = (\n                    <div className=\"m-1 px-1 bg-gray-2 dark:bg-gray-8 font-bold text-sm rounded\" key={index}>\n                      {typeof validation === 'string' ? `\"${validation}\"` : safeStringify(validation)}\n                    </div>\n                  );\n                }\n\n                return (\n                  <div key={index} className=\"py-1 flex items-baseline\">\n                    <div className=\"font-medium pr-2\">{key}:</div>\n                    <div className=\"flex-1 flex flex-wrap justify-end\">{elem}</div>\n                  </div>\n                );\n              })}\n            </div>\n          }\n          target={requiredElem}\n        />\n      ) : (\n        requiredElem\n      )}\n    </>\n  );\n};\n","import { IRowRendererOptions, isParentNode, Tree } from '@stoplight/tree-list';\nimport cn from 'classnames';\nimport * as React from 'react';\n\nimport { getNodeMetadata, getSchemaNodeMetadata } from '../tree/metadata';\nimport { GoToRefHandler, SchemaKind, SchemaTreeListNode } from '../types';\nimport { getPrimaryType } from '../utils/getPrimaryType';\nimport { hasRefItems, isRefNode } from '../utils/guards';\nimport { Caret, Description, Divider, Property, Validations } from './shared';\n\nexport interface ISchemaRow {\n  className?: string;\n  node: SchemaTreeListNode;\n  rowOptions: IRowRendererOptions;\n  onGoToRef?: GoToRefHandler;\n}\n\nconst ICON_SIZE = 12;\nconst ICON_DIMENSION = 20;\nconst ROW_OFFSET = 7;\n\nfunction isRequired(treeNode: SchemaTreeListNode) {\n  if (treeNode.parent === null) return false;\n  try {\n    const { path } = getSchemaNodeMetadata(treeNode);\n    if (path.length === 0) {\n      return false;\n    }\n\n    const { schema } = getSchemaNodeMetadata(treeNode.parent);\n\n    return (\n      getPrimaryType(schema) === SchemaKind.Object &&\n      Array.isArray(schema.required) &&\n      schema.required.includes(String(path[path.length - 1]))\n    );\n  } catch {\n    return false;\n  }\n}\n\nexport const SchemaPropertyRow: typeof SchemaRow = ({ node, onGoToRef, rowOptions }) => {\n  const metadata = getSchemaNodeMetadata(node);\n  const { schemaNode } = metadata;\n\n  const parentSchemaNode =\n    (node.parent !== null && Tree.getLevel(node.parent) >= 0 && getSchemaNodeMetadata(node.parent)?.schemaNode) || null;\n  const description = 'annotations' in schemaNode ? schemaNode.annotations.description : null;\n\n  const has$Ref = isRefNode(schemaNode) || (getPrimaryType(schemaNode) === SchemaKind.Array && hasRefItems(schemaNode));\n\n  return (\n    <>\n      {has$Ref || (isParentNode(node) && Tree.getLevel(node) > 0) ? (\n        <Caret\n          isExpanded={!!rowOptions.isExpanded}\n          style={{\n            width: ICON_DIMENSION,\n            height: ICON_DIMENSION,\n            ...(has$Ref && Tree.getLevel(node) === 0\n              ? {\n                  position: 'relative',\n                }\n              : {\n                  left: ICON_DIMENSION * -1 + ROW_OFFSET / -2,\n                }),\n          }}\n          size={ICON_SIZE}\n        />\n      ) : null}\n\n      {node.parent !== null &&\n        node.parent.children.length > 0 &&\n        parentSchemaNode !== null &&\n        'combiner' in parentSchemaNode &&\n        node.parent.children[0] !== node && <Divider kind={parentSchemaNode.combiner} />}\n\n      <div className=\"flex-1 flex truncate\">\n        <Property node={node} onGoToRef={onGoToRef} />\n        {description && <Description value={description} />}\n      </div>\n\n      <Validations\n        required={isRequired(node)}\n        validations={{\n          ...('annotations' in schemaNode &&\n            schemaNode.annotations.default && { default: schemaNode.annotations.default }),\n          ...('validations' in schemaNode && schemaNode.validations),\n        }}\n      />\n    </>\n  );\n};\nSchemaPropertyRow.displayName = 'JsonSchemaViewer.SchemaPropertyRow';\n\nexport const SchemaErrorRow: React.FunctionComponent<{ message: string }> = ({ message }) => (\n  <span className=\"text-red-5 dark:text-red-4\">{message}</span>\n);\nSchemaErrorRow.displayName = 'JsonSchemaViewer.SchemaErrorRow';\n\nexport const SchemaRow: React.FunctionComponent<ISchemaRow> = ({ className, node, rowOptions, onGoToRef }) => {\n  const metadata = getNodeMetadata(node);\n\n  return (\n    <div className={cn('px-2 flex-1 w-full', className)}>\n      <div\n        className=\"flex items-center text-sm relative\"\n        style={{\n          marginLeft: ICON_DIMENSION * Tree.getLevel(node), // offset for spacing\n        }}\n      >\n        {'schema' in metadata ? (\n          <SchemaPropertyRow node={node} onGoToRef={onGoToRef} rowOptions={rowOptions} />\n        ) : (\n          <SchemaErrorRow message={metadata.error} />\n        )}\n      </div>\n    </div>\n  );\n};\nSchemaRow.displayName = 'JsonSchemaViewer.SchemaRow';\n","import { TreeList, TreeListEvents, TreeStore } from '@stoplight/tree-list';\nimport { JSONSchema4 } from 'json-schema';\nimport { observer } from 'mobx-react-lite';\nimport * as React from 'react';\n\nimport { GoToRefHandler, RowRenderer } from '../types';\nimport { SchemaRow } from './SchemaRow';\n\nexport interface ISchemaTree {\n  treeStore: TreeStore;\n  schema: JSONSchema4;\n  name?: string;\n  hideTopBar?: boolean;\n  expanded?: boolean;\n  maxRows?: number;\n  onGoToRef?: GoToRefHandler;\n  rowRenderer?: RowRenderer;\n}\n\nconst canDrag = () => false;\n\nexport const SchemaTree = observer<ISchemaTree>(props => {\n  const { hideTopBar, name, treeStore, maxRows, onGoToRef, rowRenderer: customRowRenderer } = props;\n\n  React.useEffect(() => {\n    treeStore.events.on(TreeListEvents.NodeClick, (e, node) => {\n      if ('children' in node) {\n        treeStore.toggleExpand(node);\n      }\n    });\n\n    return () => {\n      treeStore.dispose();\n    };\n  }, [treeStore]);\n\n  const rowRenderer = React.useCallback(\n    (node, rowOptions) => {\n      if (customRowRenderer !== undefined) {\n        return customRowRenderer(node, rowOptions, treeStore);\n      }\n\n      return <SchemaRow node={node} rowOptions={rowOptions} onGoToRef={onGoToRef} />;\n    },\n    [onGoToRef, customRowRenderer, treeStore],\n  );\n\n  return (\n    <>\n      {name && !hideTopBar && (\n        <div className=\"flex items-center text-sm px-2 font-semibold\" style={{ height: 30 }}>\n          {name}\n        </div>\n      )}\n\n      <TreeList\n        striped\n        maxRows={maxRows !== undefined ? maxRows + 0.5 : maxRows}\n        store={treeStore}\n        rowRenderer={rowRenderer}\n        canDrag={canDrag}\n      />\n    </>\n  );\n});\nSchemaTree.displayName = 'JsonSchemaViewer.SchemaTree';\n","import { ErrorBoundaryForwardedProps, FallbackComponent, withErrorBoundary } from '@stoplight/react-error-boundary';\nimport { Tree, TreeState, TreeStore } from '@stoplight/tree-list';\nimport cn from 'classnames';\nimport { action } from 'mobx';\nimport * as React from 'react';\n\nimport { JSONSchema4 } from 'json-schema';\nimport { SchemaTree, SchemaTreeOptions, SchemaTreePopulateHandler, SchemaTreeRefDereferenceFn } from '../tree/tree';\nimport { GoToRefHandler, RowRenderer } from '../types';\nimport { isSchemaViewerEmpty } from '../utils/isSchemaViewerEmpty';\nimport { SchemaTree as SchemaTreeComponent } from './SchemaTree';\n\nexport interface IJsonSchemaViewer {\n  schema: JSONSchema4;\n  style?: object;\n  emptyText?: string;\n  defaultExpandedDepth?: number;\n  expanded?: boolean;\n  className?: string;\n  name?: string;\n  hideTopBar?: boolean;\n  maxRows?: number;\n  onGoToRef?: GoToRefHandler;\n  mergeAllOf?: boolean;\n  FallbackComponent?: typeof FallbackComponent;\n  rowRenderer?: RowRenderer;\n  onTreePopulate?: SchemaTreePopulateHandler;\n  resolveRef?: SchemaTreeRefDereferenceFn;\n  shouldResolveEagerly?: boolean;\n}\n\nexport class JsonSchemaViewerComponent extends React.PureComponent<IJsonSchemaViewer & ErrorBoundaryForwardedProps> {\n  protected readonly treeStore: TreeStore;\n  protected readonly tree: SchemaTree;\n  protected readonly treeState: TreeState;\n\n  constructor(props: IJsonSchemaViewer & ErrorBoundaryForwardedProps) {\n    super(props);\n\n    this.treeState = new TreeState();\n    this.tree = new SchemaTree(props.schema, this.treeState, this.treeOptions);\n    this.treeStore = new TreeStore(this.tree, this.treeState, {\n      defaultExpandedDepth: this.expandedDepth,\n    });\n  }\n\n  protected get treeOptions(): SchemaTreeOptions {\n    return {\n      expandedDepth: this.expandedDepth,\n      mergeAllOf: this.mergeAllOf,\n      resolveRef: this.props.resolveRef,\n      shouldResolveEagerly: !!this.props.shouldResolveEagerly,\n      onPopulate: this.props.onTreePopulate,\n    };\n  }\n\n  protected get mergeAllOf() {\n    return this.props.mergeAllOf !== false;\n  }\n\n  protected get expandedDepth(): number {\n    if (this.props.expanded) {\n      return Infinity; // tree-list kind of equivalent of expanded: all\n    }\n\n    if (this.props.defaultExpandedDepth !== undefined) {\n      return this.props.defaultExpandedDepth;\n    }\n\n    return 1;\n  }\n\n  protected renderSchema() {\n    if (this.tree.count > 0) {\n      this.tree.setRoot(Tree.createArtificialRoot());\n    }\n\n    this.tree.populate();\n  }\n\n  public componentDidMount() {\n    this.renderSchema();\n  }\n\n  @action\n  public componentDidUpdate(prevProps: Readonly<IJsonSchemaViewer>) {\n    if (prevProps.resolveRef !== this.props.resolveRef) {\n      this.tree.treeOptions.resolveRef = this.props.resolveRef;\n    }\n\n    if (prevProps.onTreePopulate !== this.props.onTreePopulate) {\n      this.tree.treeOptions.onPopulate = this.props.onTreePopulate;\n    }\n\n    if (\n      this.treeStore.defaultExpandedDepth !== this.expandedDepth ||\n      prevProps.schema !== this.props.schema ||\n      prevProps.mergeAllOf !== this.props.mergeAllOf ||\n      prevProps.shouldResolveEagerly !== this.props.shouldResolveEagerly\n    ) {\n      this.treeStore.defaultExpandedDepth = this.expandedDepth;\n      this.tree.treeOptions = this.treeOptions;\n      this.tree.schema = this.props.schema;\n      this.renderSchema();\n    }\n  }\n\n  public render() {\n    const {\n      props: { emptyText = 'No schema defined', name, schema, expanded, defaultExpandedDepth, className, ...props },\n    } = this;\n\n    // an empty array or object is still a valid response, schema is ONLY really empty when a combiner type has no information\n    if (isSchemaViewerEmpty(schema)) {\n      return <div>{emptyText}</div>;\n    }\n\n    return (\n      <div className={cn(className, 'JsonSchemaViewer flex flex-col relative')}>\n        <SchemaTreeComponent expanded={expanded} name={name} schema={schema} treeStore={this.treeStore} {...props} />\n      </div>\n    );\n  }\n}\n\nconst JsonSchemaFallbackComponent: typeof FallbackComponent = ({ error }) => {\n  return (\n    <div className=\"p-4\">\n      <b className=\"text-danger\">Error</b>\n      {error && `: ${error.message}`}\n    </div>\n  );\n};\n\nexport const JsonSchemaViewer = withErrorBoundary<IJsonSchemaViewer>(JsonSchemaViewerComponent, {\n  FallbackComponent: JsonSchemaFallbackComponent,\n  recoverableProps: ['schema'],\n  reportErrors: false,\n});\n"],"names":["SchemaKind","ResolvingError","ReferenceError","[object Object]","this","isArrayNodeWithItems","node","type","Array","_isObjectLike","items","isRefNode","hasRefItems","isCombinerNode","metadataStore","WeakMap","getNodeMetadata","metadata","get","Error","getSchemaNodeMetadata","TypeError","getCombiner","inferType","Object","getPrimaryType","undefined","isArray","includes","generateId","Math","random","toString","createErrorTreeNode","parent","error","path","errorNode","id","name","set","resolveAllOf","require","store","mergeAllOf","schema","opts","has","_mergeAllOf","deep","resolvers","stoplightResolvers","$ref","pathToPointer","startsWith","allRefs","schemaRefs","resolved","JSON","parse","safeStringify","resolveRef","push","ex","console","message","isValidType","maybeType","values","getTypeFromObject","obj","keys","length","flattenType","flattenTypes","types","flattenedTypes","flattened","ANNOTATIONS","getAnnotations","_pick","COMMON_VALIDATION_TYPES","VALIDATION_TYPES","string","number","integer","object","array","getTypeValidations","_flatMap","getValidations","extraValidations","deprecated","getDeprecatedValue","normalizeRequired","required","filter","item","map","String","processNode","combiner","title","properties","slice","annotations","base","validations","enum","unwrapItemsOrUndefined","additionalItems","unwrapPropertiesOrUndefined","patternProperties","additionalProperties","assignNodeSpecificFields","value","_isObject","populateTree","level","options","actualSchema","prepareSchema","fragment","walk","segment","onNode","treeNode","children","schemaNode","processRef","merged","pop","allOf","bailAllOf","i","property","entries","processArray","processObject","child","prop","resolveSchema","shouldResolveEagerly","SchemaTree","Tree","state","super","expanded","getLevel","expandedDepth","WeakSet","source","extractSourceFromRef","pointer","extractPointerFromRef","treeOptions","_get","pointerToPath","root","parentTreeNode","invalidate","onPopulate","stepIn","initialLevel","artificialRoot","createArtificialRoot","canStepIn","join","insertTreeFragment","insertNode","_isEqual","visited","unwrap","populateRefFragment","populateTreeFragment","insertErrorNode","add","schemaFragment","combinerTypes","isSchemaViewerEmpty","objectKeys","_isEmpty","Caret","style","size","isExpanded","React.createElement","className","role","Icon","iconSize","icon","Description","Popover","boundary","interactionKind","target","targetClassName","content","maxHeight","maxWidth","MarkdownViewer","markdown","DIVIDERS","anyOf","oneOf","Divider","kind","top","height","shouldRenderTitle","getPrintableType","subtype","getPrintableArrayType","Type","cn","PropertyTypeColors","displayName","Types","React.Fragment","key","any","null","boolean","binary","count","_size","retrieve$ref","Property","onGoToRef","getTitle","childrenCount","React.useMemo","handleGoToRef","React.useCallback","shouldShowPropertyName","isLocalRef","onClick","Validations","_a","_b","validationCount","requiredElem","index","validation","elem","v","isRequired","SchemaPropertyRow","rowOptions","parentSchemaNode","description","has$Ref","isParentNode","width","position","left","ICON_DIMENSION","default","SchemaErrorRow","SchemaRow","marginLeft","canDrag","observer","props","hideTopBar","treeStore","maxRows","rowRenderer","customRowRenderer","React.useEffect","events","on","TreeListEvents","NodeClick","e","toggleExpand","dispose","TreeList","striped","JsonSchemaViewerComponent","React.PureComponent","treeState","TreeState","tree","TreeStore","defaultExpandedDepth","onTreePopulate","Infinity","setRoot","populate","renderSchema","prevProps","emptyText","SchemaTreeComponent","__decorate","action","JsonSchemaViewer","withErrorBoundary","FallbackComponent","recoverableProps","reportErrors"],"mappings":"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"}