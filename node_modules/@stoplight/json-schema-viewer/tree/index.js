import{pathToPointer as e,safeStringify as t,extractSourceFromRef as r,extractPointerFromRef as n,pointerToPath as i}from"@stoplight/json";import{Tree as s}from"@stoplight/tree-list";export{TreeState as SchemaTreeState}from"@stoplight/tree-list";import{isObjectLike as o,pick as a,flatMap as l,isObject as c,get as p,isEqual as d}from"lodash";const f=new WeakMap,u=e=>{const t=f.get(e);if(void 0===t)throw new Error("Missing metadata");return t},h=e=>{const t=u(e);if(!("schema"in t))throw new TypeError("Schema node expected");return t};class m extends ReferenceError{constructor(){super(...arguments),this.name="ResolvingError"}}var y;!function(e){e.Any="any",e.String="string",e.Number="number",e.Integer="integer",e.Boolean="boolean",e.Null="null",e.Array="array",e.Object="object"}(y||(y={}));const g=e=>"$ref"in e,v=e=>(e=>"type"in e&&"items"in e&&e.type===y.Array&&o(e.items))(e)&&"$ref"in e.items,O=e=>"combiner"in e,b=e=>"allOf"in e?"allOf":"anyOf"in e?"anyOf":"oneOf"in e?"oneOf":void 0;function A(e){return"type"in e?e.type:"properties"in e?y.Object:"items"in e?y.Array:void 0}function w(e){if("type"in e&&void 0!==e.type){if(Array.isArray(e.type)){if(e.type.includes(y.Object))return y.Object;if(e.type.includes(y.Array))return y.Array}return e.type}return A(e)}const j=()=>Math.random().toString(36);function x(e,t){const{path:r}=h(e),n={id:j(),name:"",parent:e};return f.set(n,{path:r,error:t}),n}const R=require("@stoplight/json-schema-merge-allof"),$=new WeakMap;const E=(r,n,i)=>{try{return $.has(i)||$.set(i,new WeakMap),function r(n,i,s){return R(n,{deep:!1,resolvers:R.stoplightResolvers,$refResolver(o){if("string"!=typeof o)return{};if(e(i).startsWith(o))throw new m("Circular reference detected");const a=$.get(s),l=a.get(n);if(void 0===l)a.set(n,[o]);else{if(l.includes(o)){const e=JSON.parse(t(s.resolveRef(null,o)));return"allOf"in e?r(e,i,s):e}l.push(o)}return s.resolveRef(null,o)}})}(r,n,i)}catch(e){throw console.error(e.message),e}},N=e=>"string"==typeof e&&Object.values(y).includes(e);function P(e){if(Object.keys(e).length>1||!("type"in e))throw new Error('The "type" property must be a string, or an array of strings. Objects and array of objects are not valid.');if("type"in e&&N(e.type))return e.type}function I(e){return"string"==typeof e?e:"object"==typeof e&&null!==e?P(e):void 0}const k=e=>{if("string"==typeof e&&N(e))return e;if("object"==typeof e&&null!==e){if(Array.isArray(e)){const t=[];for(const r of e){const e=I(r);N(e)&&!t.includes(e)&&t.push(e)}return t.length>0?t:void 0}return P(e)}},S=["description","default","examples"];function T(e){return a(e,S)}const F=["enum","format","default","example","nullable","discriminator","readOnly","writeOnly","xml","externalDocs"],M={string:["minLength","maxLength","pattern"],number:["multipleOf","minimum","exclusiveMinimum","maximum","exclusiveMaximum"],get integer(){return this.number},object:["additionalProperties","minProperties","maxProperties"],array:["additionalItems","minItems","maxItems","uniqueItems"]};function q(e){return Array.isArray(e)?l(e,q):M[e]||[]}const L=e=>{const t=e.type&&q(e.type),r=function(e){return"x-deprecated"in e?!!e["x-deprecated"]:"deprecated"in e?!!e.deprecated:void 0}(e);return Object.assign(Object.assign(Object.assign({},a(e,F)),t&&a(e,t)),void 0!==r&&{deprecated:r})},W=e=>{if(Array.isArray(e))return e.filter(e=>"string"==typeof e||"number"==typeof e).map(String)};function C(e){const t=b(e),r=e.type||A(e),n="string"==typeof e.title?{title:e.title}:null;if(t){const i=e[t];return Object.assign(Object.assign({id:j(),combiner:t,properties:Array.isArray(i)?i.slice():i,annotations:T(e)},void 0!==r&&{type:r}),n)}if(r){const t=Object.assign(Object.assign(Object.assign({id:j(),type:k(r),validations:L(e),annotations:T(e)},"required"in e&&{required:W(e.required)}),{enum:e.enum}),n);return function(e,t){switch(w(t)){case y.Array:e.items=D(t.items),e.additionalItems="boolean"==typeof t.additionalItems?t.additionalItems:D(t.additionalItems);break;case y.Object:e.properties=B(t.properties),e.patternProperties=B(t.patternProperties),e.additionalProperties="boolean"==typeof t.additionalProperties?t.additionalProperties:B(t.additionalProperties)}}(t,e),t}return"enum"in e?Object.assign({id:j(),validations:L(e),annotations:T(e),enum:e.enum},n):"$ref"in e?Object.assign({id:j(),$ref:"string"!=typeof e.$ref?null:e.$ref},n):{id:j(),validations:{},annotations:{}}}function D(e){return c(e)?e:void 0}function B(e){return c(e)&&!Array.isArray(e)?e:void 0}const J=(e,t,r,n,i)=>{var s;const o=Q(e,t,n,i);if(c(o))for(const{node:e,fragment:a}of function*e(t){if(Array.isArray(t))for(const r of t)yield*e(r);else{const e=C(t);void 0!==e&&(yield{node:e,fragment:t})}}(o)){if(null!==i&&void 0!==i.onNode&&!i.onNode(a,e,t,r))continue;const o={id:e.id,name:"",parent:t};if(t.children.push(o),f.set(o,{schemaNode:e,schema:a,path:n}),g(e)&&null!==e.$ref)G(o,e,r,n,i);else if(O(e)){if("allOf"===e.combiner&&(null===(s=i)||void 0===s?void 0:s.mergeAllOf))try{const e=E(a,n,i);t.children.pop(),J(e,t,r,n,i)}catch(e){Array.isArray(a.allOf)&&(o.children=[],H(o,a,r+1,[...n,"allOf"],i))}else if(c(e.properties)){o.children=[];for(const[t,s]of e.properties.entries())"type"in e&&(e.properties[t]=Object.assign(Object.assign({},s),{type:s.type||e.type})),J(e.properties[t],o,r+1,[...n,e.combiner,t],i)}}else switch(w(e)){case y.Array:U(o,e,r,n,i);break;case y.Object:z(o,e,r,n,i)}}};function U(e,t,r,n,i){const s=Q(t.items,e,n,i);if(!c(s))return e;if(s!==t.items){const t=u(e);"schemaNode"in t&&(t.schemaNode.items=s)}if("$ref"in s)G(e,s,r,n,i);else if(Array.isArray(s)){const t=[];e.children=t;for(const[o,a]of s.entries()){const s=J(a,e,r+1,[...n,"items",o],i);void 0!==s&&t.push(s)}}else{switch(w(s)){case y.Object:return z(e,s,r,[...n,"items"],i);case y.Array:return U(e,s,r,[...n,"items"],i);default:b(s)&&(e.children=[],J(s,e,r,[...n,"items"],i))}}return e}function z(e,t,r,n,i){const s=[];if(c(t.properties)){e.children=s;for(const[o,a]of Object.entries(t.properties)){const t=J(a,e,r+1,[...n,"properties",o],i);void 0!==t&&s.push(t)}}if(c(t.patternProperties)){e.children=s;for(const[o,a]of Object.entries(t.patternProperties)){const t=J(a,e,r+1,[...n,"patternProperties",o],i);void 0!==t&&s.push(t)}}return e}function G(e,t,r,n,i){e.children=[];try{const r=K(t,n,i);if(c(r)&&"string"==typeof r.title){const{schemaNode:t}=h(e);t.title=r.title}}catch(e){}}function H(e,t,r,n,i){if(Array.isArray(t.allOf))for(const[s,o]of t.allOf.entries())J(o,e,r,[...n,s],i)}function K(e,t,r){if(!(c(e)&&null!==r&&"$ref"in e&&"string"==typeof e.$ref))return e;const n=r.resolveRef(t,e.$ref);return c(n)?n:e}function Q(e,t,r,n){if(null===n||!n.shouldResolveEagerly)return e;try{return K(e,r,n)}catch(e){return t.children=[],void t.children.push(x(t,e.message))}}class V extends s{constructor(e,t,s){super({expanded:e=>!(e.id in t.expanded)&&V.getLevel(e)<=s.expandedDepth||!0===t.expanded[e.id]}),this.schema=e,this.state=t,this.visited=new WeakSet,this.resolveRef=(e,t)=>{const s=r(t),o=n(t);if(void 0!==this.treeOptions.resolveRef)return this.treeOptions.resolveRef({source:s,pointer:o},e,this.schema);if(null!==s)throw new m("Cannot dereference external references");if(null===o)throw new m("The pointer is empty");return p(this.schema,i(o))},this.treeOptions=s}populate(){var e,t;const r={};J(this.schema,this.root,0,[],{mergeAllOf:this.treeOptions.mergeAllOf,onNode:(e,t,n,i)=>{!this.treeOptions.shouldResolveEagerly&&(g(t)&&null!==t.$ref||v(t)&&null!==t.items.$ref)&&(r[t.id]=!1);const o=s.getLevel(n)>=0?h(n):void 0;return(void 0===o||!g(o.schemaNode))&&i<=this.treeOptions.expandedDepth+1},resolveRef:this.resolveRef,shouldResolveEagerly:this.treeOptions.shouldResolveEagerly}),this.state.expanded=r,this.invalidate(),null===(t=(e=this.treeOptions).onPopulate)||void 0===t||t.call(e,this,this.root)}populateTreeFragment(e,t,r,n){var i,o;const a=s.getLevel(e),l=s.createArtificialRoot();if(J(t,l,a,r,{mergeAllOf:this.treeOptions.mergeAllOf,onNode:(e,t,r,i)=>i<=this.treeOptions.expandedDepth||i<=a||n&&i<=a+1&&(e=>{if(b(e))return!0;const t=w(e);return t===y.Array||t===y.Object})(h(r).schema),resolveRef:this.resolveRef,shouldResolveEagerly:this.treeOptions.shouldResolveEagerly}),0===l.children.length)throw new Error(`Could not expand node ${r.join(".")}`);this.insertTreeFragment(n?this.stepIn(l,e):l.children,e),null===(o=(i=this.treeOptions).onPopulate)||void 0===o||o.call(i,this,e)}insertErrorNode(e,t){this.insertNode(x(e,t),e)}stepIn(e,t){return e.children.length>0&&"children"in e.children[0]&&d(h(t).path,h(e.children[0]).path)?e.children[0].children:e.children}unwrap(e){if(0!==e.children.length||this.visited.has(e))return super.unwrap(e);const t=h(e),{path:r,schemaNode:n,schema:i}=t;try{if(g(n)||v(n))if(g(n))this.populateRefFragment(e,r,n.$ref);else{if(!v(n))throw new Error(`I do know not how to expand this node ${r.join(".")}`);this.populateRefFragment(e,[...r,"items"],n.items.$ref)}else this.populateTreeFragment(e,i,r,!0)}catch(t){this.insertErrorNode(e,t.message)}return this.visited.add(e),super.unwrap(e)}populateRefFragment(e,t,r){if(null===r)throw new Error("Unknown $ref value");const n=this.resolveRef(t,r);if(!c(n))throw new m(`Could not dereference "${r}"`);this.populateTreeFragment(e,n,t,!1)}}export{V as SchemaTree,u as getNodeMetadata};
//# sourceMappingURL=index.js.map
