{"version":3,"file":"index.js","sources":["../../src/tree/metadata.ts","../../src/errors.ts","../../src/types.ts","../../src/utils/guards.ts","../../src/utils/getCombiner.ts","../../src/utils/inferType.ts","../../src/utils/getPrimaryType.ts","../../src/tree/utils/canStepIn.ts","../../src/utils/generateId.ts","../../src/tree/utils/createErrorTreeNode.ts","../../src/tree/utils/mergeAllOf.ts","../../src/utils/isValidType.ts","../../src/utils/flattenTypes.ts","../../src/utils/getAnnotations.ts","../../src/utils/getValidations.ts","../../src/utils/normalizeRequired.ts","../../src/tree/utils/walk.ts","../../src/tree/utils/populateTree.ts","../../src/tree/tree.ts"],"sourcesContent":["import { TreeListNode } from '@stoplight/tree-list';\nimport { JsonPath } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { SchemaNode, SchemaTreeListNode } from '../types';\n\nexport interface ITreeNodeMetaSchema {\n  path: JsonPath;\n  schemaNode: SchemaNode;\n  schema: JSONSchema4;\n}\n\nexport interface ITreeNodeMetaError {\n  path: JsonPath;\n  error: string;\n}\n\nexport type TreeNodeMeta = ITreeNodeMetaSchema | ITreeNodeMetaError;\n\nexport const metadataStore = new WeakMap<SchemaTreeListNode, TreeNodeMeta>();\n\nexport const getNodeMetadata = (node: TreeListNode): TreeNodeMeta => {\n  const metadata = metadataStore.get(node);\n  if (metadata === void 0) {\n    throw new Error('Missing metadata');\n  }\n\n  return metadata;\n};\n\nexport const getSchemaNodeMetadata = (node: TreeListNode): ITreeNodeMetaSchema => {\n  const metadata = getNodeMetadata(node);\n\n  if (!('schema' in metadata)) {\n    throw new TypeError('Schema node expected');\n  }\n\n  return metadata;\n};\n","export class ResolvingError extends ReferenceError {\n  public readonly name = 'ResolvingError';\n}\n","import { IRowRendererOptions, TreeListNode, TreeStore } from '@stoplight/tree-list';\nimport { Dictionary } from '@stoplight/types';\nimport { JSONSchema4, JSONSchema4TypeName } from 'json-schema';\nimport * as React from 'react';\n\nexport enum SchemaKind {\n  Any = 'any',\n  String = 'string',\n  Number = 'number',\n  Integer = 'integer',\n  Boolean = 'boolean',\n  Null = 'null',\n  Array = 'array',\n  Object = 'object',\n}\n\nexport type JSONSchema4CombinerName = 'allOf' | 'anyOf' | 'oneOf';\n\nexport type JSONSchema4Annotations = 'title' | 'description' | 'default' | 'examples';\n\nexport type JSONSchema4Metadata = 'id' | '$schema';\n\nexport interface ICombinerNode {\n  id: string;\n  readonly combiner: JSONSchema4CombinerName;\n  properties?: JSONSchema4[];\n  annotations: Pick<JSONSchema4, JSONSchema4Annotations>;\n  readonly type?: JSONSchema4TypeName | JSONSchema4TypeName[];\n  title?: string;\n}\n\nexport interface IBaseNode extends Pick<JSONSchema4, 'enum'> {\n  id: string;\n  readonly type?: JSONSchema4TypeName | JSONSchema4TypeName[];\n  annotations: Partial<Pick<JSONSchema4, JSONSchema4Annotations>>;\n  validations: Dictionary<unknown>;\n  required?: string[];\n  title?: string;\n}\n\nexport interface IRefNode {\n  id: string;\n  $ref: string | null;\n  title?: string;\n}\n\nexport interface IArrayNode extends IBaseNode, Pick<JSONSchema4, 'items' | 'additionalItems'> {}\n\nexport interface IObjectNode\n  extends IBaseNode,\n    Pick<JSONSchema4, 'properties' | 'patternProperties' | 'additionalProperties'> {}\n\nexport interface IObjectPropertyNode extends IBaseNode {\n  name: string;\n}\n\nexport type SchemaNode = ICombinerNode | IBaseNode | IArrayNode | IObjectNode | IObjectPropertyNode | IRefNode;\n\nexport type SchemaTreeListNode = TreeListNode;\n\nexport type GoToRefHandler = (path: string, node: IRefNode) => void;\n\nexport type RowRenderer = (\n  node: TreeListNode,\n  rowOptions: IRowRendererOptions,\n  treeStore: TreeStore,\n) => React.ReactNode;\n","import { JSONSchema4 } from 'json-schema';\nimport { isObjectLike as _isObjectLike } from 'lodash';\nimport { IArrayNode, ICombinerNode, IRefNode, SchemaKind, SchemaNode } from '../types';\n\nexport const isArrayNodeWithItems = (\n  node: SchemaNode,\n): node is Omit<IArrayNode, 'items'> & { items: JSONSchema4 | JSONSchema4[] } =>\n  'type' in node && 'items' in node && node.type === SchemaKind.Array && _isObjectLike(node.items);\n\nexport const isRefNode = (node: SchemaNode): node is IRefNode => '$ref' in node;\n\nexport const hasRefItems = (node: SchemaNode): node is Omit<IArrayNode, 'items'> & { items: Omit<IRefNode, 'id'> } =>\n  isArrayNodeWithItems(node) && '$ref' in node.items;\n\nexport const isCombinerNode = (node: SchemaNode): node is ICombinerNode => 'combiner' in node;\n","import { JSONSchema4 } from 'json-schema';\nimport { JSONSchema4CombinerName } from '../types';\n\nexport const getCombiner = (node: JSONSchema4): JSONSchema4CombinerName | void => {\n  if ('allOf' in node) return 'allOf';\n  if ('anyOf' in node) return 'anyOf';\n  if ('oneOf' in node) return 'oneOf';\n};\n","import { Optional } from '@stoplight/types';\nimport { JSONSchema4, JSONSchema4TypeName } from 'json-schema';\nimport { SchemaKind, SchemaNode } from '../types';\n\nexport function inferType(node: SchemaNode | JSONSchema4): Optional<JSONSchema4TypeName | JSONSchema4TypeName[]> {\n  if ('type' in node) {\n    return node.type;\n  }\n\n  if ('properties' in node) {\n    return SchemaKind.Object;\n  }\n\n  if ('items' in node) {\n    return SchemaKind.Array;\n  }\n\n  return;\n}\n","import { JSONSchema4 } from 'json-schema';\nimport { SchemaKind, SchemaNode } from '../types';\nimport { inferType } from './inferType';\n\nexport function getPrimaryType(node: JSONSchema4 | SchemaNode) {\n  if ('type' in node && node.type !== undefined) {\n    if (Array.isArray(node.type)) {\n      if (node.type.includes(SchemaKind.Object)) {\n        return SchemaKind.Object;\n      }\n\n      if (node.type.includes(SchemaKind.Array)) {\n        return SchemaKind.Array;\n      }\n    }\n\n    return node.type;\n  }\n\n  return inferType(node);\n}\n","import { JSONSchema4 } from 'json-schema';\nimport { SchemaKind } from '../../types';\nimport { getCombiner } from '../../utils/getCombiner';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\n\nexport const canStepIn = (fragment: JSONSchema4) => {\n  if (getCombiner(fragment)) {\n    return true;\n  }\n\n  const type = getPrimaryType(fragment);\n  return type === SchemaKind.Array || type === SchemaKind.Object;\n};\n","export const generateId = (): string => Math.random().toString(36);\n","import { TreeListParentNode } from '@stoplight/tree-list';\nimport { SchemaTreeListNode } from '../../types';\nimport { generateId } from '../../utils/generateId';\nimport { getSchemaNodeMetadata, metadataStore } from '../metadata';\n\nexport function createErrorTreeNode(parent: TreeListParentNode, error: string) {\n  const { path } = getSchemaNodeMetadata(parent);\n\n  const errorNode: SchemaTreeListNode = {\n    id: generateId(),\n    name: '',\n    parent,\n  };\n\n  metadataStore.set(errorNode, {\n    path,\n    error,\n  });\n\n  return errorNode;\n}\n","import { pathToPointer, safeStringify } from '@stoplight/json';\nimport { JsonPath } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { ResolvingError } from '../../errors';\nimport { WalkingOptions } from './populateTree';\n\nconst resolveAllOf = require('@stoplight/json-schema-merge-allof');\n\nconst store = new WeakMap<WalkingOptions, WeakMap<JSONSchema4, string[]>>();\n\nfunction _mergeAllOf(schema: JSONSchema4, path: JsonPath, opts: WalkingOptions) {\n  return resolveAllOf(schema, {\n    deep: false,\n    resolvers: resolveAllOf.stoplightResolvers,\n    $refResolver($ref: unknown) {\n      if (typeof $ref !== 'string') {\n        return {};\n      }\n\n      if (pathToPointer(path).startsWith($ref)) {\n        throw new ResolvingError('Circular reference detected');\n      }\n\n      const allRefs = store.get(opts)!;\n      const schemaRefs = allRefs.get(schema);\n\n      if (schemaRefs === void 0) {\n        allRefs.set(schema, [$ref]);\n      } else if (schemaRefs.includes($ref)) {\n        const resolved = JSON.parse(safeStringify(opts.resolveRef(null, $ref)));\n        return 'allOf' in resolved ? _mergeAllOf(resolved, path, opts) : resolved;\n      } else {\n        schemaRefs.push($ref);\n      }\n\n      return opts.resolveRef(null, $ref);\n    },\n  });\n}\n\nexport const mergeAllOf = (schema: JSONSchema4, path: JsonPath, opts: WalkingOptions) => {\n  try {\n    if (!store.has(opts)) {\n      store.set(opts, new WeakMap());\n    }\n\n    return _mergeAllOf(schema, path, opts);\n  } catch (ex) {\n    console.error(ex.message);\n    throw ex;\n  }\n};\n","import { JSONSchema4TypeName } from 'json-schema';\nimport { SchemaKind } from '../types';\n\nexport const isValidType = (maybeType: unknown): maybeType is JSONSchema4TypeName =>\n  typeof maybeType === 'string' && Object.values(SchemaKind).includes(maybeType as SchemaKind);\n","import { Optional } from '@stoplight/types';\nimport { JSONSchema4TypeName } from 'json-schema';\nimport { isValidType } from './isValidType';\n\nfunction getTypeFromObject(obj: object): Optional<JSONSchema4TypeName> {\n  const size = Object.keys(obj).length;\n\n  if (size > 1 || !('type' in obj)) {\n    throw new Error(\n      'The \"type\" property must be a string, or an array of strings. Objects and array of objects are not valid.',\n    );\n  }\n\n  if ('type' in obj && isValidType((obj as { type: string }).type)) {\n    return (obj as { type: JSONSchema4TypeName }).type;\n  }\n\n  return;\n}\n\nfunction flattenType(type: unknown) {\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  if (typeof type !== 'object' || type === null) {\n    return;\n  }\n\n  return getTypeFromObject(type);\n}\n\nexport const flattenTypes = (types: unknown): Optional<JSONSchema4TypeName | JSONSchema4TypeName[]> => {\n  if (typeof types === 'string' && isValidType(types)) {\n    return types;\n  }\n\n  if (typeof types !== 'object' || types === null) {\n    return;\n  }\n\n  if (Array.isArray(types)) {\n    const flattenedTypes: JSONSchema4TypeName[] = [];\n    for (const type of types) {\n      const flattened = flattenType(type);\n      if (!isValidType(flattened) || flattenedTypes.includes(flattened)) continue;\n      flattenedTypes.push(flattened);\n    }\n\n    return flattenedTypes.length > 0 ? flattenedTypes : void 0;\n  }\n\n  return getTypeFromObject(types);\n};\n","import { JSONSchema4 } from 'json-schema';\nimport { pick as _pick } from 'lodash';\nimport { JSONSchema4Annotations } from '../types';\n\nconst ANNOTATIONS: JSONSchema4Annotations[] = ['description', 'default', 'examples'];\n\nexport function getAnnotations(node: JSONSchema4) {\n  return _pick(node, ANNOTATIONS);\n}\n","import { Dictionary, Optional } from '@stoplight/types';\nimport { JSONSchema4, JSONSchema4TypeName } from 'json-schema';\nimport { flatMap as _flatMap, pick as _pick } from 'lodash';\n\nexport const COMMON_VALIDATION_TYPES = [\n  'enum', // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1\n  'format', // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7\n  'default',\n  'example',\n  'nullable',\n  'discriminator',\n  'readOnly',\n  'writeOnly',\n  'xml',\n  'externalDocs',\n];\n\nconst VALIDATION_TYPES = {\n  string: ['minLength', 'maxLength', 'pattern'],\n  number: ['multipleOf', 'minimum', 'exclusiveMinimum', 'maximum', 'exclusiveMaximum'],\n  get integer() {\n    return this.number;\n  },\n  object: ['additionalProperties', 'minProperties', 'maxProperties'],\n  array: ['additionalItems', 'minItems', 'maxItems', 'uniqueItems'],\n};\n\nfunction getDeprecatedValue(node: JSONSchema4): Optional<boolean> {\n  if ('x-deprecated' in node) {\n    return !!node['x-deprecated'];\n  }\n\n  if ('deprecated' in node) {\n    return !!node.deprecated;\n  }\n\n  return;\n}\n\nfunction getTypeValidations(type: JSONSchema4TypeName | JSONSchema4TypeName[]): string[] {\n  if (Array.isArray(type)) {\n    return _flatMap(type, getTypeValidations);\n  }\n\n  return VALIDATION_TYPES[type] || [];\n}\n\nexport const getValidations = (node: JSONSchema4): Dictionary<unknown> => {\n  const extraValidations = node.type && getTypeValidations(node.type);\n  const deprecated = getDeprecatedValue(node);\n  return {\n    ..._pick(node, COMMON_VALIDATION_TYPES),\n    ...(extraValidations && _pick(node, extraValidations)),\n    ...(deprecated !== void 0 && { deprecated }),\n  };\n};\n","import { Optional } from '@stoplight/types';\n\nexport const normalizeRequired = (required: unknown): Optional<string[]> => {\n  if (!Array.isArray(required)) return;\n  return required.filter(item => typeof item === 'string' || typeof item === 'number').map(String);\n};\n","import { Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { isObject as _isObject } from 'lodash';\nimport { IArrayNode, IBaseNode, ICombinerNode, IObjectNode, SchemaKind, SchemaNode } from '../../types';\nimport { flattenTypes } from '../../utils/flattenTypes';\nimport { generateId } from '../../utils/generateId';\nimport { getAnnotations } from '../../utils/getAnnotations';\nimport { getCombiner } from '../../utils/getCombiner';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\nimport { getValidations } from '../../utils/getValidations';\nimport { inferType } from '../../utils/inferType';\nimport { normalizeRequired } from '../../utils/normalizeRequired';\n\nfunction assignNodeSpecificFields(base: IBaseNode, node: JSONSchema4) {\n  switch (getPrimaryType(node)) {\n    case SchemaKind.Array:\n      (base as IArrayNode).items = unwrapItemsOrUndefined(node.items);\n      (base as IArrayNode).additionalItems =\n        typeof node.additionalItems === 'boolean' ? node.additionalItems : unwrapItemsOrUndefined(node.additionalItems);\n      break;\n    case SchemaKind.Object:\n      (base as IObjectNode).properties = unwrapPropertiesOrUndefined(node.properties);\n      (base as IObjectNode).patternProperties = unwrapPropertiesOrUndefined(node.patternProperties);\n      (base as IObjectNode).additionalProperties =\n        typeof node.additionalProperties === 'boolean'\n          ? node.additionalProperties\n          : unwrapPropertiesOrUndefined(node.additionalProperties);\n      break;\n  }\n}\n\nfunction processNode(node: JSONSchema4): SchemaNode | void {\n  const combiner = getCombiner(node);\n  const type = node.type || inferType(node);\n  const title = typeof node.title === 'string' ? { title: node.title } : null;\n\n  if (combiner) {\n    const properties = node[combiner];\n    return {\n      id: generateId(),\n      combiner,\n      properties: Array.isArray(properties) ? properties.slice() : properties,\n      annotations: getAnnotations(node),\n      ...(type !== undefined && { type }),\n      ...title,\n    } as ICombinerNode;\n  }\n\n  if (type) {\n    const base: IBaseNode = {\n      id: generateId(),\n      type: flattenTypes(type),\n      validations: getValidations(node),\n      annotations: getAnnotations(node),\n      ...('required' in node && { required: normalizeRequired(node.required) }),\n      enum: node.enum,\n      ...title,\n    };\n\n    assignNodeSpecificFields(base, node);\n\n    return base;\n  }\n\n  if ('enum' in node) {\n    return {\n      id: generateId(),\n      validations: getValidations(node),\n      annotations: getAnnotations(node),\n      enum: node.enum,\n      ...title,\n    };\n  }\n\n  if ('$ref' in node) {\n    return {\n      id: generateId(),\n      $ref: typeof node.$ref !== 'string' ? null : node.$ref,\n      ...title,\n    };\n  }\n\n  // if ('not' in node) {\n  //   // todo: shall we support it?\n  // }\n\n  return {\n    id: generateId(),\n    validations: {},\n    annotations: {},\n  };\n}\n\nexport type WalkerValue = {\n  node: SchemaNode;\n  fragment: JSONSchema4;\n};\n\nexport function* walk(schema: JSONSchema4[] | JSONSchema4): IterableIterator<WalkerValue> {\n  if (Array.isArray(schema)) {\n    for (const segment of schema) {\n      yield* walk(segment);\n    }\n  } else {\n    const node = processNode(schema);\n    if (node !== void 0) {\n      yield {\n        node,\n        fragment: schema,\n      };\n    }\n  }\n}\n\nfunction unwrapItemsOrUndefined<T = unknown>(value: T): Optional<T> {\n  return _isObject(value) ? value : void 0;\n}\n\nfunction unwrapPropertiesOrUndefined<T = unknown>(value: T): Optional<T> {\n  return _isObject(value) && !Array.isArray(value) ? value : void 0;\n}\n","import { TreeListNode, TreeListParentNode } from '@stoplight/tree-list';\nimport { JsonPath, Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { isObject as _isObject } from 'lodash';\nimport { IArrayNode, IObjectNode, SchemaKind, SchemaNode, SchemaTreeListNode } from '../../types';\nimport { getCombiner } from '../../utils/getCombiner';\nimport { getPrimaryType } from '../../utils/getPrimaryType';\nimport { isCombinerNode, isRefNode } from '../../utils/guards';\nimport { getNodeMetadata, getSchemaNodeMetadata, metadataStore } from '../metadata';\nimport { createErrorTreeNode } from './createErrorTreeNode';\nimport { mergeAllOf } from './mergeAllOf';\nimport { walk } from './walk';\n\nexport type WalkerRefResolver = (path: JsonPath | null, $ref: string) => JSONSchema4;\n\nexport type WalkingOptions = {\n  mergeAllOf: boolean;\n  onNode?(fragment: JSONSchema4, node: SchemaNode, parentTreeNode: TreeListNode, level: number): boolean | void;\n  stepIn?: boolean;\n  resolveRef: WalkerRefResolver;\n  shouldResolveEagerly: boolean;\n};\n\nexport type Walker = (\n  schema: Optional<JSONSchema4 | null>,\n  parent: TreeListParentNode,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n) => undefined;\n\nexport const populateTree: Walker = (schema, parent, level, path, options): undefined => {\n  const actualSchema = prepareSchema(schema, parent, path, options);\n\n  if (!_isObject(actualSchema)) return;\n\n  for (const { node, fragment } of walk(actualSchema)) {\n    if (options !== null && options.onNode !== void 0 && !options.onNode(fragment, node, parent, level)) continue;\n\n    const treeNode: SchemaTreeListNode = {\n      id: node.id,\n      name: '',\n      parent,\n    };\n\n    parent.children.push(treeNode);\n    metadataStore.set(treeNode, {\n      schemaNode: node,\n      schema: fragment,\n      path,\n    });\n\n    if (isRefNode(node) && node.$ref !== null) {\n      processRef(treeNode, node as JSONSchema4, level, path, options);\n    } else if (!isCombinerNode(node)) {\n      switch (getPrimaryType(node)) {\n        case SchemaKind.Array:\n          processArray(treeNode, node as IArrayNode, level, path, options);\n          break;\n        case SchemaKind.Object:\n          processObject(treeNode, node as IObjectNode, level, path, options);\n          break;\n      }\n    } else if (node.combiner === 'allOf' && options?.mergeAllOf) {\n      try {\n        const merged = mergeAllOf(fragment, path, options);\n        parent.children.pop();\n        populateTree(merged, parent, level, path, options);\n      } catch (ex) {\n        if (Array.isArray(fragment.allOf)) {\n          (treeNode as TreeListParentNode).children = [];\n          bailAllOf(treeNode as TreeListParentNode, fragment, level + 1, [...path, 'allOf'], options);\n        }\n      }\n    } else if (_isObject(node.properties)) {\n      (treeNode as TreeListParentNode).children = [];\n\n      for (const [i, property] of node.properties.entries()) {\n        if ('type' in node) {\n          node.properties[i] = {\n            ...property,\n            type: property.type || node.type,\n          };\n        }\n\n        populateTree(\n          node.properties[i],\n          treeNode as TreeListParentNode,\n          level + 1,\n          [...path, node.combiner, i],\n          options,\n        );\n      }\n    }\n  }\n\n  return;\n};\n\nfunction processArray(\n  node: SchemaTreeListNode,\n  schema: IArrayNode,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n): SchemaTreeListNode {\n  const items = prepareSchema(schema.items, node, path, options);\n\n  if (!_isObject(items)) return node;\n\n  if (items !== schema.items) {\n    // we need to update the stored metadata to make sure the subtype of given array correctly inferred by Property component\n    const metadata = getNodeMetadata(node);\n    if ('schemaNode' in metadata) {\n      (metadata.schemaNode as IArrayNode).items = items;\n    }\n  }\n\n  if ('$ref' in items) {\n    processRef(node, items, level, path, options);\n  } else if (Array.isArray(items)) {\n    const children: SchemaTreeListNode[] = [];\n    (node as TreeListParentNode).children = children;\n    for (const [i, property] of items.entries()) {\n      const child = populateTree(property, node as TreeListParentNode, level + 1, [...path, 'items', i], options);\n      if (child !== void 0) {\n        children.push(child);\n      }\n    }\n  } else {\n    const subtype = getPrimaryType(items);\n    switch (subtype) {\n      case SchemaKind.Object:\n        return processObject(node, items as IObjectNode, level, [...path, 'items'], options);\n      case SchemaKind.Array:\n        return processArray(node, items as IObjectNode, level, [...path, 'items'], options);\n      default:\n        const combiner = getCombiner(items);\n        if (combiner) {\n          (node as TreeListParentNode).children = [];\n          populateTree(items, node as TreeListParentNode, level, [...path, 'items'], options);\n        }\n    }\n  }\n\n  return node;\n}\n\nfunction processObject(\n  node: TreeListNode,\n  schema: IObjectNode,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n): TreeListNode {\n  const children: TreeListNode[] = [];\n\n  if (_isObject(schema.properties)) {\n    (node as TreeListParentNode).children = children;\n\n    for (const [prop, property] of Object.entries(schema.properties)) {\n      const child = populateTree(\n        property,\n        node as TreeListParentNode,\n        level + 1,\n        [...path, 'properties', prop],\n        options,\n      );\n      if (child !== void 0) {\n        children.push(child);\n      }\n    }\n  }\n\n  if (_isObject(schema.patternProperties)) {\n    (node as TreeListParentNode).children = children;\n\n    for (const [prop, property] of Object.entries(schema.patternProperties)) {\n      const child = populateTree(\n        property,\n        node as TreeListParentNode,\n        level + 1,\n        [...path, 'patternProperties', prop],\n        options,\n      );\n      if (child !== void 0) {\n        children.push(child);\n      }\n    }\n  }\n\n  return node;\n}\n\nfunction processRef(\n  node: TreeListNode,\n  schema: JSONSchema4,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n) {\n  (node as TreeListParentNode).children = [];\n  try {\n    const resolved = resolveSchema(schema, path, options);\n    if (_isObject(resolved) && typeof resolved.title === 'string') {\n      const { schemaNode } = getSchemaNodeMetadata(node);\n      schemaNode.title = resolved.title;\n    }\n  } catch {\n    // resolving failed, nothing bad. We just won't have the title\n  }\n}\n\nfunction bailAllOf(\n  node: TreeListParentNode,\n  schema: JSONSchema4,\n  level: number,\n  path: JsonPath,\n  options: WalkingOptions | null,\n) {\n  if (Array.isArray(schema.allOf)) {\n    for (const [i, item] of schema.allOf.entries()) {\n      populateTree(item, node, level, [...path, i], options);\n    }\n  }\n}\n\nfunction resolveSchema(schema: Optional<JSONSchema4 | null>, path: JsonPath, options: WalkingOptions | null) {\n  if (!_isObject(schema) || options === null || !('$ref' in schema) || typeof schema.$ref !== 'string') {\n    return schema;\n  }\n\n  const resolved = options.resolveRef(path, schema.$ref);\n  return _isObject(resolved) ? resolved : schema;\n}\n\nfunction prepareSchema(\n  schema: Optional<JSONSchema4 | null>,\n  node: TreeListNode,\n  path: JsonPath,\n  options: WalkingOptions | null,\n): Optional<JSONSchema4 | null> {\n  if (options === null || !options.shouldResolveEagerly) return schema;\n\n  try {\n    return resolveSchema(schema, path, options);\n  } catch (ex) {\n    (node as TreeListParentNode).children = [];\n    return void (node as TreeListParentNode).children.push(createErrorTreeNode(node as TreeListParentNode, ex.message));\n  }\n}\n","import { extractPointerFromRef, extractSourceFromRef, pointerToPath } from '@stoplight/json';\nimport { Tree, TreeListParentNode, TreeState } from '@stoplight/tree-list';\nimport { JsonPath, Optional } from '@stoplight/types';\nimport { JSONSchema4 } from 'json-schema';\nimport { get as _get, isEqual as _isEqual, isObject as _isObject } from 'lodash';\nimport { ResolvingError } from '../errors';\nimport { hasRefItems, isRefNode } from '../utils/guards';\nimport { getSchemaNodeMetadata } from './metadata';\nimport { canStepIn } from './utils/canStepIn';\nimport { createErrorTreeNode } from './utils/createErrorTreeNode';\nimport { populateTree, WalkerRefResolver } from './utils/populateTree';\n\nexport type SchemaTreeRefInfo = {\n  source: string | null;\n  pointer: string | null;\n};\n\nexport type SchemaTreeRefDereferenceFn = (\n  ref: SchemaTreeRefInfo,\n  propertyPath: JsonPath | null,\n  schema: JSONSchema4,\n) => Optional<JSONSchema4>;\n\nexport type SchemaTreePopulateHandler = (tree: SchemaTree, node: TreeListParentNode) => void;\n\nexport type SchemaTreeOptions = {\n  expandedDepth: number;\n  mergeAllOf: boolean;\n  resolveRef: Optional<SchemaTreeRefDereferenceFn>;\n  shouldResolveEagerly: boolean;\n  onPopulate: Optional<SchemaTreePopulateHandler>;\n};\n\nexport { TreeState as SchemaTreeState };\n\nexport class SchemaTree extends Tree {\n  public treeOptions: SchemaTreeOptions;\n\n  constructor(public schema: JSONSchema4, public state: TreeState, opts: SchemaTreeOptions) {\n    super({\n      expanded: node =>\n        (!(node.id in state.expanded) && SchemaTree.getLevel(node) <= opts.expandedDepth) ||\n        state.expanded[node.id] === true,\n    });\n\n    this.treeOptions = opts;\n  }\n\n  protected readonly visited = new WeakSet();\n\n  public populate() {\n    const expanded = {};\n    populateTree(this.schema, this.root, 0, [], {\n      mergeAllOf: this.treeOptions.mergeAllOf,\n      onNode: (fragment, node, parentTreeNode, level): boolean => {\n        if (\n          !this.treeOptions.shouldResolveEagerly &&\n          ((isRefNode(node) && node.$ref !== null) || (hasRefItems(node) && node.items.$ref !== null))\n        ) {\n          expanded[node.id] = false;\n        }\n\n        const metadata = Tree.getLevel(parentTreeNode) >= 0 ? getSchemaNodeMetadata(parentTreeNode) : void 0;\n\n        if (metadata !== void 0 && isRefNode(metadata.schemaNode)) return false;\n        return level <= this.treeOptions.expandedDepth + 1;\n      },\n      resolveRef: this.resolveRef,\n      shouldResolveEagerly: this.treeOptions.shouldResolveEagerly,\n    });\n    this.state.expanded = expanded;\n    this.invalidate();\n    this.treeOptions.onPopulate?.(this, this.root);\n  }\n\n  public populateTreeFragment(parent: TreeListParentNode, schema: JSONSchema4, path: JsonPath, stepIn: boolean) {\n    const initialLevel = Tree.getLevel(parent);\n    const artificialRoot = Tree.createArtificialRoot();\n    populateTree(schema, artificialRoot, initialLevel, path, {\n      mergeAllOf: this.treeOptions.mergeAllOf,\n      onNode: (fragment, node, parentTreeNode, level) => {\n        if (level <= this.treeOptions.expandedDepth || level <= initialLevel) return true;\n        return stepIn && level <= initialLevel + 1 && canStepIn(getSchemaNodeMetadata(parentTreeNode).schema);\n      },\n      resolveRef: this.resolveRef,\n      shouldResolveEagerly: this.treeOptions.shouldResolveEagerly,\n    });\n\n    if (artificialRoot.children.length === 0) {\n      throw new Error(`Could not expand node ${path.join('.')}`);\n    }\n\n    this.insertTreeFragment(stepIn ? this.stepIn(artificialRoot, parent) : artificialRoot.children, parent);\n\n    this.treeOptions.onPopulate?.(this, parent);\n  }\n\n  protected insertErrorNode(parent: TreeListParentNode, error: string) {\n    this.insertNode(createErrorTreeNode(parent, error), parent);\n  }\n\n  protected stepIn(root: TreeListParentNode, parent: TreeListParentNode) {\n    if (\n      root.children.length > 0 &&\n      'children' in root.children[0] &&\n      _isEqual(getSchemaNodeMetadata(parent).path, getSchemaNodeMetadata(root.children[0]).path)\n    ) {\n      return root.children[0].children;\n    }\n\n    return root.children;\n  }\n\n  public unwrap(node: TreeListParentNode) {\n    if (node.children.length !== 0 || this.visited.has(node)) {\n      return super.unwrap(node);\n    }\n    const metadata = getSchemaNodeMetadata(node);\n    const { path, schemaNode, schema } = metadata;\n    try {\n      if (!isRefNode(schemaNode) && !hasRefItems(schemaNode)) {\n        this.populateTreeFragment(node, schema, path, true);\n      } else if (isRefNode(schemaNode)) {\n        this.populateRefFragment(node, path, schemaNode.$ref);\n      } else if (hasRefItems(schemaNode)) {\n        this.populateRefFragment(node, [...path, 'items'], schemaNode.items.$ref);\n      } else {\n        throw new Error(`I do know not how to expand this node ${path.join('.')}`);\n      }\n    } catch (ex) {\n      this.insertErrorNode(node, ex.message);\n    }\n\n    this.visited.add(node);\n    return super.unwrap(node);\n  }\n\n  protected resolveRef: WalkerRefResolver = (path, $ref) => {\n    const source = extractSourceFromRef($ref);\n    const pointer = extractPointerFromRef($ref);\n\n    if (this.treeOptions.resolveRef !== void 0) {\n      return this.treeOptions.resolveRef({ source, pointer }, path, this.schema);\n    } else if (source !== null) {\n      throw new ResolvingError('Cannot dereference external references');\n    } else if (pointer === null) {\n      throw new ResolvingError('The pointer is empty');\n    } else {\n      return _get(this.schema, pointerToPath(pointer));\n    }\n  };\n\n  protected populateRefFragment(node: TreeListParentNode, path: JsonPath, $ref: string | null) {\n    if ($ref === null) {\n      throw new Error('Unknown $ref value');\n    }\n\n    const schemaFragment = this.resolveRef(path, $ref);\n\n    if (!_isObject(schemaFragment)) {\n      throw new ResolvingError(`Could not dereference \"${$ref}\"`);\n    }\n\n    this.populateTreeFragment(node, schemaFragment, path, false);\n  }\n}\n"],"names":["metadataStore","WeakMap","getNodeMetadata","node","metadata","get","Error","getSchemaNodeMetadata","TypeError","ResolvingError","ReferenceError","[object Object]","this","SchemaKind","isRefNode","hasRefItems","type","Array","_isObjectLike","items","isArrayNodeWithItems","isCombinerNode","getCombiner","inferType","Object","getPrimaryType","undefined","isArray","includes","generateId","Math","random","toString","createErrorTreeNode","parent","error","path","errorNode","id","name","set","resolveAllOf","require","store","mergeAllOf","schema","opts","has","_mergeAllOf","deep","resolvers","stoplightResolvers","$ref","pathToPointer","startsWith","allRefs","schemaRefs","resolved","JSON","parse","safeStringify","resolveRef","push","ex","console","message","isValidType","maybeType","values","getTypeFromObject","obj","keys","length","flattenType","flattenTypes","types","flattenedTypes","flattened","ANNOTATIONS","getAnnotations","_pick","COMMON_VALIDATION_TYPES","VALIDATION_TYPES","string","number","integer","object","array","getTypeValidations","_flatMap","getValidations","extraValidations","deprecated","getDeprecatedValue","normalizeRequired","required","filter","item","map","String","processNode","combiner","title","properties","slice","annotations","base","validations","enum","unwrapItemsOrUndefined","additionalItems","unwrapPropertiesOrUndefined","patternProperties","additionalProperties","assignNodeSpecificFields","value","_isObject","populateTree","level","options","actualSchema","prepareSchema","fragment","walk","segment","onNode","treeNode","children","schemaNode","processRef","merged","pop","allOf","bailAllOf","i","property","entries","processArray","processObject","child","prop","resolveSchema","shouldResolveEagerly","SchemaTree","Tree","state","super","expanded","getLevel","expandedDepth","WeakSet","source","extractSourceFromRef","pointer","extractPointerFromRef","treeOptions","_get","pointerToPath","root","parentTreeNode","invalidate","onPopulate","stepIn","initialLevel","artificialRoot","createArtificialRoot","canStepIn","join","insertTreeFragment","insertNode","_isEqual","visited","unwrap","populateRefFragment","populateTreeFragment","insertErrorNode","add","schemaFragment"],"mappings":"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"}