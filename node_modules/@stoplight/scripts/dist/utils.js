"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = require("fs");
const path = require("path");
exports.buildCommand = (baseCommand, { defaultArgs = {}, rawArgs = [], flags = [], } = {}) => {
    let command = path.resolve(process.cwd(), 'node_modules', '.bin', baseCommand);
    for (const arg of rawArgs) {
        if (!flags.includes(arg.input.substring(2)))
            command += ` ${arg.input}`;
    }
    for (const arg in defaultArgs) {
        if (!defaultArgs.hasOwnProperty(arg) || command.match(arg))
            continue;
        command += ' ' + defaultArgs[arg];
    }
    return command;
};
exports.runCommand = (command, { handleError = true } = {}) => {
    try {
        return child_process_1.execSync(command, {
            stdio: 'inherit',
            cwd: process.cwd(),
            env: Object.assign({}, process.env),
        });
    }
    catch (error) {
        if (handleError) {
            return process.exit(error.status);
        }
        else {
            throw error;
        }
    }
};
exports.getConfigFilePath = (name) => {
    const filePath = path.resolve(process.cwd(), name);
    if (fs.existsSync(path.resolve(process.cwd(), name))) {
        return filePath;
    }
    return path.resolve(process.cwd(), 'node_modules', '@stoplight', 'scripts', name);
};
exports.buildPath = (...args) => {
    return path.resolve(process.cwd(), ...args);
};
exports.sortObjKeys = (obj) => {
    return Object.keys(obj)
        .sort()
        .reduce((accumulator, currentValue) => {
        accumulator[currentValue] = obj[currentValue];
        return accumulator;
    }, {});
};
//# sourceMappingURL=utils.js.map