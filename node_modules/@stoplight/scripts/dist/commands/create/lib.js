"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const fs = require("fs");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const path = require("path");
const shell = require("shelljs");
const utils_1 = require("../../utils");
class CreateLibCommand extends command_1.Command {
    constructor() {
        super(...arguments);
        this.templateDir = () => path.resolve(__dirname, '..', '..', '..', 'templates');
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const responses = yield inquirer.prompt([
                {
                    name: 'name',
                    default: '@stoplight/library',
                    validate: val => {
                        return !val.trim() ? 'name is required' : true;
                    },
                },
                {
                    name: 'description',
                },
                {
                    name: 'author',
                    default: 'Stoplight <support@stoplight.io>',
                },
                {
                    name: 'repository',
                    default: (answers) => `https://github.com/stoplightio/${answers.name.replace('@stoplight/', '')}`,
                },
                {
                    name: 'license',
                    type: 'list',
                    choices: [{ name: 'Apache 2', value: 'apache2' }, { name: 'None', value: false }],
                },
                {
                    name: 'react',
                    message: 'needs react?',
                    type: 'expand',
                    default: 0,
                    choices: [{ key: 'Y', name: 'Yes', value: true }, { key: 'n', name: 'No', value: false }],
                },
                {
                    name: 'ci',
                    type: 'list',
                    choices: [{ name: 'CircleCI', value: 'circle' }],
                },
                {
                    name: 'quality',
                    type: 'list',
                    choices: [{ name: 'Code Climate', value: 'codeclimate' }],
                },
            ]);
            const cleanedName = responses.name.replace('@stoplight/', '');
            const targetDir = path.resolve(process.cwd(), cleanedName);
            if (shell.test('-e', targetDir)) {
                this.error(`'${targetDir}' directory already exists. Cannot create library.`);
            }
            this.writeScaffold(targetDir);
            this.writeIgnore(targetDir);
            this.writeLicense(targetDir, responses);
            this.writeCi(targetDir, responses);
            this.writeQuality(targetDir, responses);
            this.writePackage(targetDir, responses);
            this.writeReadme(targetDir, responses);
            this.writeStorybook(targetDir, responses);
            this.writeSrc(targetDir, responses);
            this.log(`Done! Change into the '${cleanedName}' directory to get started.`);
        });
    }
    writeScaffold(targetDir) {
        shell.mkdir(targetDir);
        shell.cp('-Rfn', path.resolve(this.templateDir(), 'common', '*'), targetDir);
    }
    writeIgnore(targetDir) {
        shell.cp('-Rfn', path.resolve(this.templateDir(), 'gitignore'), path.resolve(targetDir, '.gitignore'));
    }
    writeLicense(targetDir, responses) {
        if (!responses.license)
            return;
        if (responses.license === 'apache2') {
            shell.cp('-Rfn', path.resolve(this.templateDir(), 'licenses', 'apache2', '*'), targetDir);
        }
    }
    writeStorybook(targetDir, responses) {
        if (!responses.react)
            return;
        shell.cp('-Rfn', path.resolve(this.templateDir(), '.storybook'), targetDir);
    }
    writeCi(targetDir, responses) {
        if (!responses.ci)
            return;
        if (responses.ci === 'circle') {
            const circleDir = path.resolve(targetDir, '.circleci');
            shell.mkdir(circleDir);
            shell.cp('-Rfn', path.resolve(this.templateDir(), 'ci', '.circleci', '*'), circleDir);
        }
    }
    writeQuality(targetDir, responses) {
        if (!responses.quality)
            return;
        if (responses.quality === 'codeclimate') {
            shell.cp('-Rfn', path.resolve(this.templateDir(), 'quality', '.codeclimate.yml'), targetDir);
        }
    }
    writePackage(targetDir, responses) {
        const pkgPath = path.resolve(targetDir, 'package.json');
        const pkg = this.createPackage(responses);
        fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
    }
    createPackage(responses) {
        const pkg = JSON.parse(fs.readFileSync(path.resolve(this.templateDir(), 'pkgs', 'base.json')));
        pkg.name = responses.name;
        pkg.description = responses.description;
        pkg.author = responses.author;
        pkg.repository.url = responses.repository;
        const githubUrl = responses.repository.replace('.git', '');
        pkg.homepage = githubUrl;
        pkg.bugs = `${githubUrl}/issues`;
        lodash_1.merge(pkg, JSON.parse(fs.readFileSync(path.resolve(this.templateDir(), 'pkgs', 'release.json'))));
        if (responses.license === 'apache2') {
            pkg.license = 'Apache-2.0';
        }
        if (responses.react) {
            lodash_1.merge(pkg, JSON.parse(fs.readFileSync(path.resolve(this.templateDir(), 'pkgs', 'react.json'))));
            lodash_1.merge(pkg, JSON.parse(fs.readFileSync(path.resolve(this.templateDir(), 'pkgs', 'storybook.json'))));
        }
        if (pkg.scripts)
            pkg.scripts = utils_1.sortObjKeys(pkg.scripts);
        if (pkg.peerDependencies)
            pkg.peerDependencies = utils_1.sortObjKeys(pkg.peerDependencies);
        if (pkg.dependencies)
            pkg.dependencies = utils_1.sortObjKeys(pkg.dependencies);
        if (pkg.devDependencies)
            pkg.devDependencies = utils_1.sortObjKeys(pkg.devDependencies);
        return pkg;
    }
    writeReadme(targetDir, responses) {
        const readmePath = path.resolve(targetDir, 'README.md');
        let readme = fs.readFileSync(readmePath, 'utf8');
        readme = readme.replace(new RegExp('<!-- NAME -->', 'g'), responses.name);
        if (responses.description) {
            readme = readme.replace(new RegExp('<!-- SUMMARY -->', 'g'), responses.description);
        }
        if (responses.repository) {
            readme = readme.replace(new RegExp('<!-- GIT_REPO -->', 'g'), responses.repository);
        }
        if (responses.repository) {
            const repoParts = responses.repository.split('/');
            const docsUrl = `https://${repoParts[repoParts.length - 2]}.github.io/${repoParts[repoParts.length - 1]}`;
            if (responses.react) {
                readme = readme.replace(new RegExp('<!-- DOCS_LINK -->', 'g'), `Explore the components: [Storybook](${docsUrl})`);
            }
            else {
                readme = readme.replace(new RegExp('<!-- DOCS_LINK -->', 'g'), `Explore the interfaces: [TSDoc](${docsUrl})`);
            }
        }
        fs.writeFileSync(readmePath, readme);
    }
    writeSrc(targetDir, responses) {
        if (responses.react) {
            shell.cp('-Rfn', path.resolve(this.templateDir(), 'srcs', 'react', '*'), targetDir);
        }
        else {
            shell.cp('-Rfn', path.resolve(this.templateDir(), 'srcs', 'lib', '*'), targetDir);
        }
    }
}
exports.default = CreateLibCommand;
CreateLibCommand.description = 'Scaffold out a new library.';
CreateLibCommand.examples = [`$ sl-scripts create:lib`];
CreateLibCommand.args = [];
CreateLibCommand.flags = {};
//# sourceMappingURL=lib.js.map