"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const cli_ux_1 = require("cli-ux");
const fs = require("fs");
const path_1 = require("path");
const shelljs_1 = require("shelljs");
const utils_1 = require("../../utils");
const _pick = require('lodash/pick');
class BuildCommand extends command_1.Command {
    get commands() {
        const parsed = this.parse(BuildCommand);
        return [
            utils_1.buildCommand('tsc', {
                defaultArgs: {
                    '--project': `--project ${utils_1.getConfigFilePath('tsconfig.build.json')}`,
                },
                rawArgs: parsed.raw,
                flags: Object.keys(BuildCommand.flags),
            }),
        ];
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            cli_ux_1.default.action.start('building...', undefined, { stdout: true });
            const parsed = this.parse(BuildCommand);
            const commands = [`${utils_1.buildCommand('rimraf')} dist`, ...this.commands];
            if (parsed.flags.verbose) {
                this.log(`commands:`);
                for (const command of commands) {
                    this.log(`    '${command}'`);
                }
            }
            for (const command of commands) {
                utils_1.runCommand(command);
            }
            cli_ux_1.default.action.stop();
            this.postPublish();
        });
    }
    preparePackageJson() {
        const pkg = JSON.parse(fs.readFileSync(utils_1.buildPath('package.json')));
        const releasePkg = _pick(pkg, [
            'name',
            'version',
            'description',
            'keywords',
            'main',
            'typings',
            'sideEffects',
            'files',
            'author',
            'repository',
            'license',
            'engines',
            'browser',
            'optionalDependencies',
            'peerDependencies',
            'peerDependenciesMeta',
            'dependencies',
            'dependenciesMeta',
            'pkg',
        ]);
        releasePkg.main = 'index.js';
        if (!('typings' in releasePkg)) {
            releasePkg.typings = 'index.d.ts';
        }
        return releasePkg;
    }
    postPublish() {
        cli_ux_1.default.action.start('copying extra files ot dist folder...', undefined, {
            stdout: true,
        });
        const releasePkg = this.preparePackageJson();
        for (const [name, version] of Object.entries(releasePkg.dependencies)) {
            if (version.startsWith('file:')) {
                const filepath = version.replace('file:', '');
                const installPath = utils_1.buildPath('dist', 'node_modules', name);
                shelljs_1.mkdir('-p', path_1.dirname(installPath));
                shelljs_1.cp('-r', utils_1.buildPath(filepath), installPath);
                if (!releasePkg.bundledDependencies) {
                    releasePkg.bundledDependencies = [];
                }
                releasePkg.bundledDependencies.push(name);
                delete releasePkg.dependencies[name];
            }
        }
        fs.writeFileSync(utils_1.buildPath('dist', 'package.json'), JSON.stringify(releasePkg, null, 2));
        fs.copyFileSync(utils_1.buildPath('README.md'), utils_1.buildPath('dist', 'README.md'));
        fs.copyFileSync(utils_1.buildPath('LICENSE'), utils_1.buildPath('dist', 'LICENSE'));
        cli_ux_1.default.action.stop();
    }
}
exports.default = BuildCommand;
BuildCommand.strict = false;
BuildCommand.description = 'Build source code';
BuildCommand.examples = [`$ sl-scripts build`];
BuildCommand.args = [];
BuildCommand.flags = {
    verbose: command_1.flags.boolean({
        description: 'moar logs',
        required: false,
    }),
};
//# sourceMappingURL=index.js.map