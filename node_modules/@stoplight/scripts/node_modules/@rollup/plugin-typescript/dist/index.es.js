import { resolve, win32, posix } from 'path';
import { readFile, readFileSync } from 'fs';
import { createFilter } from '@rollup/pluginutils';
import * as defaultTs from 'typescript';
import resolveId from 'resolve';

// `Cannot compile modules into 'es6' when targeting 'ES5' or lower.`
const CANNOT_COMPILE_ESM = 1204;
/**
 * For each type error reported by Typescript, emit a Rollup warning or error.
 */
function emitDiagnostics(ts, context, host, diagnostics) {
    if (!diagnostics)
        return;
    const { noEmitOnError } = host.getCompilationSettings();
    diagnostics
        .filter((diagnostic) => diagnostic.code !== CANNOT_COMPILE_ESM)
        .forEach((diagnostic) => {
        // Build a Rollup warning object from the diagnostics object.
        const warning = diagnosticToWarning(ts, host, diagnostic);
        // Errors are fatal. Otherwise emit warnings.
        if (noEmitOnError && diagnostic.category === ts.DiagnosticCategory.Error) {
            context.error(warning);
        }
        else {
            context.warn(warning);
        }
    });
}
/**
 * Converts a Typescript type error into an equivalent Rollup warning object.
 */
function diagnosticToWarning(ts, host, diagnostic) {
    const pluginCode = `TS${diagnostic.code}`;
    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
    // Build a Rollup warning object from the diagnostics object.
    const warning = {
        pluginCode,
        message: `@rollup/plugin-typescript ${pluginCode}: ${message}`
    };
    if (diagnostic.file) {
        // Add information about the file location
        const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
        warning.loc = {
            column: character + 1,
            line: line + 1,
            file: diagnostic.file.fileName
        };
        if (host) {
            // Extract a code frame from Typescript
            const formatted = ts.formatDiagnosticsWithColorAndContext([diagnostic], host);
            // Typescript only exposes this formatter as a string prefixed with the flattened message.
            // We need to remove it here since Rollup treats the properties as separate parts.
            let frame = formatted.slice(formatted.indexOf(message) + message.length);
            const newLine = host.getNewLine();
            if (frame.startsWith(newLine)) {
                frame = frame.slice(frame.indexOf(newLine) + newLine.length);
            }
            warning.frame = frame;
        }
    }
    return warning;
}

/**
 * Map of Typescript instances to paths to DocumentRegistries.
 */
const globalRegistryCache = new Map();
/**
 * Return a `DocumentRegistry` instance that matches the given Typescript instance
 * and working directory. If there is no a pre-existing instance, one will be
 * created and set in the map.
 */
function getDocumentRegistry(ts, cwd) {
    if (!globalRegistryCache.has(ts)) {
        globalRegistryCache.set(ts, new Map());
    }
    const instanceRegistryCache = globalRegistryCache.get(ts);
    if (!instanceRegistryCache.has(cwd)) {
        instanceRegistryCache.set(cwd, ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd));
    }
    return instanceRegistryCache.get(cwd);
}

/**
 * Create a helper for resolving modules using Typescript.
 */
function createModuleResolver(ts, host) {
    const compilerOptions = host.getCompilationSettings();
    const cache = ts.createModuleResolutionCache(process.cwd(), host.getCanonicalFileName, compilerOptions);
    return (moduleName, containingFile) => {
        const resolved = ts.nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache);
        return resolved.resolvedModule;
    };
}

/**
 * Create a language service host to use with the Typescript compiler & type checking APIs.
 * @param parsedOptions Parsed options for Typescript.
 * @param parsedOptions.options Typescript compiler options. Affects functions such as `getNewLine`.
 * @param parsedOptions.fileNames Declaration files to include for typechecking.
 * @see https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
 */
function createHost(ts, parsedOptions) {
    const files = new Map();
    /** Get the code stored in a File snapshot. */
    function getCode({ file }) {
        return file.getText(0, file.getLength());
    }
    /** @see TypescriptHost.addFile */
    function addFile(id, code) {
        const existing = files.get(id);
        // Don't need to update if nothing changed
        if (existing && getCode(existing) === code)
            return;
        files.set(id, {
            file: ts.ScriptSnapshot.fromString(code),
            version: existing ? existing.version + 1 : 0
        });
    }
    /** Helper that tries to read the file if it hasn't been stored yet */
    function getFile(id) {
        if (!files.has(id)) {
            const code = ts.sys.readFile(id);
            if (code == null) {
                throw new Error(`@rollup/plugin-typescript: Could not find ${id}`);
            }
            addFile(id, code);
        }
        return files.get(id);
    }
    parsedOptions.fileNames.forEach((id) => getFile(id));
    let resolver;
    const host = {
        getCompilationSettings: () => parsedOptions.options,
        getCurrentDirectory: () => process.cwd(),
        getNewLine: () => getNewLine(ts, parsedOptions.options.newLine),
        getCanonicalFileName: (fileName) => ts.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase(),
        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
        getDefaultLibFileName: ts.getDefaultLibFilePath,
        getDirectories: ts.sys.getDirectories,
        directoryExists: ts.sys.directoryExists,
        realpath: ts.sys.realpath,
        readDirectory: ts.sys.readDirectory,
        readFile(fileName, encoding) {
            const file = files.get(fileName);
            if (file != null)
                return getCode(file);
            return ts.sys.readFile(fileName, encoding);
        },
        fileExists: (fileName) => files.has(fileName) || ts.sys.fileExists(fileName),
        getScriptFileNames: () => Array.from(files.keys()),
        getScriptSnapshot: (fileName) => getFile(fileName).file,
        getScriptVersion: (fileName) => getFile(fileName).version.toString(),
        resolveModuleNames(moduleNames, containingFile) {
            return moduleNames.map((moduleName) => resolver(moduleName, containingFile));
        },
        addFile
    };
    // Declared here because this has a circular reference
    resolver = createModuleResolver(ts, host);
    return host;
}
/**
 * Returns the string that corresponds with the selected `NewLineKind`.
 */
function getNewLine(ts, kind) {
    switch (kind) {
        case ts.NewLineKind.CarriageReturnLineFeed:
            return '\r\n';
        case ts.NewLineKind.LineFeed:
            return '\n';
        default:
            return ts.sys.newLine;
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const TSLIB_ID = '\0tslib';
const readFileAsync = (file) => new Promise((fulfil, reject) => readFile(file, 'utf-8', (err, contents) => (err ? reject(err) : fulfil(contents))));
const resolveIdAsync = (file, opts) => new Promise((fulfil, reject) => resolveId(file, opts, (err, contents) => (err ? reject(err) : fulfil(contents))));
/**
 * Returns code asynchronously for the tslib helper library.
 * @param customHelperCode Overrides the injected helpers with a custom version.
 */
async function getTsLibCode(customHelperCode) {
    if (customHelperCode)
        return customHelperCode;
    const defaultPath = await resolveIdAsync('tslib/tslib.es6.js', { basedir: __dirname });
    return readFileAsync(defaultPath);
}

const DEFAULT_COMPILER_OPTIONS = {
    module: 'esnext',
    sourceMap: true,
    noEmitOnError: true
};
const FORCED_COMPILER_OPTIONS = {
    // See: https://github.com/rollup/rollup-plugin-typescript/issues/45
    // See: https://github.com/rollup/rollup-plugin-typescript/issues/142
    declaration: false,
    // Delete the `declarationMap` option, as it will cause an error, because we have
    // deleted the `declaration` option.
    declarationMap: false,
    incremental: false,
    // eslint-disable-next-line no-undefined
    tsBuildInfoFile: undefined,
    // Always use tslib
    noEmitHelpers: true,
    importHelpers: true,
    // Typescript needs to emit the code for us to work with
    noEmit: false,
    emitDeclarationOnly: false,
    // Preventing Typescript from resolving code may break compilation
    noResolve: false
};
/**
 * Separate the Rollup plugin options from the Typescript compiler options,
 * and normalize the Rollup options.
 * @returns Object with normalized options:
 * - `filter`: Checks if a file should be included.
 * - `tsconfig`: Path to a tsconfig, or directive to ignore tsconfig.
 * - `compilerOptions`: Custom Typescript compiler options that override tsconfig.
 * - `typescript`: Instance of Typescript library (possibly custom).
 * - `tslib`: ESM code from the tslib helper library (possibly)
 */
function getPluginOptions(options) {
    const { include, exclude, tsconfig, typescript, tslib } = options, compilerOptions = __rest(options, ["include", "exclude", "tsconfig", "typescript", "tslib"]);
    const filter = createFilter(include || ['*.ts+(|x)', '**/*.ts+(|x)'], exclude || ['*.d.ts', '**/*.d.ts']);
    return {
        filter,
        tsconfig,
        compilerOptions: compilerOptions,
        typescript: typescript || defaultTs,
        tslib: getTsLibCode(tslib)
    };
}
/**
 * Finds the path to the tsconfig file relative to the current working directory.
 * @param relativePath Relative tsconfig path given by the user.
 * If `false` is passed, then a null path is returned.
 * @returns The absolute path, or null if the file does not exist.
 */
function getTsConfigPath(ts, relativePath) {
    if (relativePath === false)
        return null;
    // Resolve path to file. `tsConfigOption` defaults to 'tsconfig.json'.
    const tsConfigPath = resolve(process.cwd(), relativePath || 'tsconfig.json');
    if (!ts.sys.fileExists(tsConfigPath)) {
        if (relativePath) {
            // If an explicit path was provided but no file was found, throw
            throw new Error(`Could not find specified tsconfig.json at ${tsConfigPath}`);
        }
        else {
            return null;
        }
    }
    return tsConfigPath;
}
/**
 * Tries to read the tsconfig file at `tsConfigPath`.
 * @param tsConfigPath Absolute path to tsconfig JSON file.
 * @param explicitPath If true, the path was set by the plugin user.
 * If false, the path was computed automatically.
 */
function readTsConfigFile(ts, tsConfigPath) {
    var _a;
    const { config, error } = ts.readConfigFile(tsConfigPath, (path) => readFileSync(path, 'utf8'));
    if (error) {
        throw Object.assign(Error(), diagnosticToWarning(ts, null, error));
    }
    const extendedTsConfig = (_a = config) === null || _a === void 0 ? void 0 : _a.extends;
    if (extendedTsConfig) {
        // Get absolute path of `extends`, starting at basedir of the tsconfig file.
        config.extends = resolve(process.cwd(), tsConfigPath, '..', extendedTsConfig);
    }
    return config || {};
}
/**
 * Returns true if any of the `compilerOptions` contain an enum value (i.e.: ts.ScriptKind) rather than a string.
 * This indicates that the internal CompilerOptions type is used rather than the JsonCompilerOptions.
 */
function containsEnumOptions(compilerOptions) {
    const enums = [
        'module',
        'target',
        'jsx',
        'moduleResolution',
        'newLine'
    ];
    return enums.some((prop) => prop in compilerOptions && typeof compilerOptions[prop] === 'number');
}
/**
 * Mutates the compiler options to normalize some values for Rollup.
 * @param compilerOptions Compiler options to _mutate_.
 */
function normalizeCompilerOptions(ts, compilerOptions) {
    /* eslint-disable no-param-reassign */
    if (compilerOptions.inlineSourceMap) {
        // Force separate source map files for Rollup to work with.
        compilerOptions.sourceMap = true;
        compilerOptions.inlineSourceMap = false;
    }
    else if (typeof compilerOptions.sourceMap !== 'boolean') {
        // Default to using source maps.
        // If the plugin user sets sourceMap to false we keep that option.
        compilerOptions.sourceMap = true;
    }
    switch (compilerOptions.module) {
        case ts.ModuleKind.ES2015:
        case ts.ModuleKind.ESNext:
        case ts.ModuleKind.CommonJS:
            // OK module type
            return;
        case ts.ModuleKind.None:
        case ts.ModuleKind.AMD:
        case ts.ModuleKind.UMD:
        case ts.ModuleKind.System: {
            // Invalid module type
            const moduleType = ts.ModuleKind[compilerOptions.module];
            throw new Error(`@rollup/plugin-typescript: The module kind should be 'ES2015' or 'ESNext, found: '${moduleType}'`);
        }
        default:
            // Unknown or unspecified module type, force ESNext
            compilerOptions.module = ts.ModuleKind.ESNext;
    }
}
/**
 * Parse the Typescript config to use with the plugin.
 * @param ts Typescript library instance.
 * @param tsconfig Path to the tsconfig file, or `false` to ignore the file.
 * @param compilerOptions Options passed to the plugin directly for Typescript.
 *
 * @returns Parsed tsconfig.json file with some important properties:
 * - `options`: Parsed compiler options.
 * - `fileNames` Type definition files that should be included in the build.
 * - `errors`: Any errors from parsing the config file.
 */
function parseTypescriptConfig(ts, tsconfig, compilerOptions) {
    const cwd = process.cwd();
    let parsedConfig;
    // Resolve path to file. If file is not found, pass undefined path to `parseJsonConfigFileContent`.
    // eslint-disable-next-line no-undefined
    const tsConfigPath = getTsConfigPath(ts, tsconfig) || undefined;
    const tsConfigFile = tsConfigPath ? readTsConfigFile(ts, tsConfigPath) : {};
    // If compilerOptions has enums, it represents an CompilerOptions object instead of parsed JSON.
    // This determines where the data is passed to the parser.
    if (containsEnumOptions(compilerOptions)) {
        parsedConfig = ts.parseJsonConfigFileContent(Object.assign(Object.assign({}, tsConfigFile), { compilerOptions: Object.assign(Object.assign({}, DEFAULT_COMPILER_OPTIONS), tsConfigFile.compilerOptions) }), ts.sys, cwd, Object.assign(Object.assign({}, compilerOptions), FORCED_COMPILER_OPTIONS), tsConfigPath);
    }
    else {
        parsedConfig = ts.parseJsonConfigFileContent(Object.assign(Object.assign({}, tsConfigFile), { compilerOptions: Object.assign(Object.assign(Object.assign({}, DEFAULT_COMPILER_OPTIONS), tsConfigFile.compilerOptions), compilerOptions) }), ts.sys, cwd, FORCED_COMPILER_OPTIONS, tsConfigPath);
    }
    // We only want to automatically add ambient declaration files.
    // Normal script files are handled by Rollup.
    parsedConfig.fileNames = parsedConfig.fileNames.filter((file) => file.endsWith('.d.ts'));
    normalizeCompilerOptions(ts, parsedConfig.options);
    return parsedConfig;
}

/**
 * Checks if the given OutputFile represents some code
 */
function isCodeOutputFile(file) {
    return !isMapOutputFile(file) && !file.name.endsWith('.d.ts');
}
/**
 * Checks if the given OutputFile represents some source map
 */
function isMapOutputFile({ name }) {
    return name.endsWith('.map');
}
/**
 * Transforms a Typescript EmitOutput into a Rollup SourceDescription.
 */
function typescriptOutputToRollupTransformation(outputFiles) {
    var _a;
    const code = outputFiles.find(isCodeOutputFile);
    if (code == null)
        return null;
    const map = outputFiles.find(isMapOutputFile);
    return {
        code: code.text,
        map: (_a = map) === null || _a === void 0 ? void 0 : _a.text
    };
}

function typescript(options = {}) {
    const { filter, tsconfig, compilerOptions, tslib, typescript: ts } = getPluginOptions(options);
    const parsedOptions = parseTypescriptConfig(ts, tsconfig, compilerOptions);
    const host = createHost(ts, parsedOptions);
    const services = ts.createLanguageService(host, getDocumentRegistry(ts, process.cwd()));
    return {
        name: 'typescript',
        buildStart() {
            if (parsedOptions.errors.length > 0) {
                parsedOptions.errors.forEach((error) => this.warn(diagnosticToWarning(ts, host, error)));
                this.error(`@rollup/plugin-typescript: Couldn't process compiler options`);
            }
        },
        resolveId(importee, importer) {
            var _a;
            if (importee === 'tslib') {
                return TSLIB_ID;
            }
            if (!importer)
                return null;
            // Convert path from windows separators to posix separators
            const containingFile = importer.split(win32.sep).join(posix.sep);
            const resolved = host.resolveModuleNames([importee], containingFile);
            const resolvedFile = (_a = resolved[0]) === null || _a === void 0 ? void 0 : _a.resolvedFileName;
            if (resolvedFile) {
                if (resolvedFile.endsWith('.d.ts'))
                    return null;
                return resolvedFile;
            }
            return null;
        },
        load(id) {
            if (id === TSLIB_ID) {
                return tslib;
            }
            return null;
        },
        transform(code, id) {
            if (!filter(id))
                return null;
            host.addFile(id, code);
            const output = services.getEmitOutput(id);
            if (output.emitSkipped) {
                // Emit failed, print all diagnostics for this file
                const allDiagnostics = []
                    .concat(services.getSyntacticDiagnostics(id))
                    .concat(services.getSemanticDiagnostics(id));
                emitDiagnostics(ts, this, host, allDiagnostics);
                throw new Error(`Couldn't compile ${id}`);
            }
            return typescriptOutputToRollupTransformation(output.outputFiles);
        },
        generateBundle() {
            const program = services.getProgram();
            if (program == null)
                return;
            emitDiagnostics(ts, this, host, ts.getPreEmitDiagnostics(program));
        }
    };
}

export default typescript;
